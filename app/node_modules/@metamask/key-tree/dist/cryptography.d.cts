export type CryptographicFunctions = {
    /**
     * Compute the HMAC-SHA-512 of the given data using the given key.
     *
     * @param key - The key to use.
     * @param data - The data to hash.
     * @returns The HMAC-SHA-512 of the data.
     */
    hmacSha512?: (key: Uint8Array, data: Uint8Array) => Promise<Uint8Array>;
    /**
     * Compute the PBKDF2 of the given password, salt, iterations, and key length.
     * The hash function used is SHA-512.
     *
     * @param password - The password to hash.
     * @param salt - The salt to use.
     * @param iterations - The number of iterations.
     * @param keyLength - The desired key length in bytes.
     * @returns The PBKDF2 of the password.
     */
    pbkdf2Sha512?: (password: Uint8Array, salt: Uint8Array, iterations: number, keyLength: number) => Promise<Uint8Array>;
};
/**
 * Compute the HMAC-SHA-512 of the given data using the given key.
 *
 * This function uses the Web Crypto API if available, falling back to a
 * JavaScript implementation if not.
 *
 * @param key - The key to use.
 * @param data - The data to hash.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The HMAC-SHA-512 of the data.
 */
export declare function hmacSha512(key: Uint8Array, data: Uint8Array, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
/**
 * Compute the Keccak-256 of the given data synchronously.
 *
 * Right now this is just a wrapper around `keccak256` from the `@noble/hashes`
 * package, but it's here in case we want to change the implementation in the
 * future to allow for asynchronous hashing.
 *
 * @param data - The data to hash.
 * @returns The Keccak-256 of the data.
 */
export declare function keccak256(data: Uint8Array): Uint8Array;
/**
 * Compute the PBKDF2 of the given password, salt, iterations, and key length.
 * The hash function used is SHA-512.
 *
 * @param password - The password to hash.
 * @param salt - The salt to use.
 * @param iterations - The number of iterations.
 * @param keyLength - The desired key length.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The PBKDF2 of the password.
 */
export declare function pbkdf2Sha512(password: Uint8Array, salt: Uint8Array, iterations: number, keyLength: number, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
/**
 * Compute the RIPEMD-160 of the given data.
 *
 * Right now this is just a wrapper around `ripemd160` from the `@noble/hashes`
 * package, but it's here in case we want to change the implementation in the
 * future to allow for asynchronous hashing.
 *
 * @param data - The data to hash.
 * @returns The RIPEMD-160 of the data.
 */
export declare function ripemd160(data: Uint8Array): Uint8Array;
/**
 * Compute the SHA-256 of the given data synchronously.
 *
 * Right now this is just a wrapper around `sha256` from the `@noble/hashes`
 * package, but it's here in case we want to change the implementation in the
 * future to allow for asynchronous hashing.
 *
 * @param data - The data to hash.
 * @returns The SHA-256 of the data.
 */
export declare function sha256(data: Uint8Array): Uint8Array;
//# sourceMappingURL=cryptography.d.cts.map