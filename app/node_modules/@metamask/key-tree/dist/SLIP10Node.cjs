"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _SLIP10Node_constructorGuard, _SLIP10Node_publicKeyBytes, _SLIP10Node_cryptographicFunctions;
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildNode = exports.validateRootIndex = exports.validateMasterParentFingerprint = exports.validateParentFingerprint = exports.validateBIP32Depth = exports.SLIP10Node = void 0;
const utils_1 = require("@metamask/utils");
const constants_1 = require("./constants.cjs");
const curves_1 = require("./curves/index.cjs");
const derivation_1 = require("./derivation.cjs");
const bip32_1 = require("./derivers/bip32.cjs");
const bip39_1 = require("./derivers/bip39.cjs");
const extended_keys_1 = require("./extended-keys.cjs");
const guard_1 = require("./guard.cjs");
const utils_2 = require("./utils.cjs");
class SLIP10Node {
    /**
     * Wrapper of the {@link fromExtendedKey} function. Refer to that function
     * for documentation.
     *
     * @param json - The JSON representation of a SLIP-10 node.
     * @param cryptographicFunctions - The cryptographic functions to use. If
     * provided, these will be used instead of the built-in implementations.
     * @returns A SLIP10 node.
     */
    static async fromJSON(json, cryptographicFunctions) {
        return _a.fromExtendedKey(json, cryptographicFunctions);
    }
    /**
     * Create a new SLIP-10 node from a key and chain code. You must specify
     * either a private key or a public key. When specifying a private key,
     * the public key will be derived from the private key.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * @param options - The options for the new node. This can be an object
     * containing the extended key options, or a string containing the extended
     * key.
     * @param options.depth - The depth of the node.
     * @param options.masterFingerprint - The fingerprint of the master node, i.e., the
     * node at depth 0. May be undefined if this node was created from an extended
     * key.
     * @param options.parentFingerprint - The fingerprint of the parent key, or 0 if
     * the node is a master node.
     * @param options.index - The index of the node, or 0 if the node is a master node.
     * @param options.privateKey - The private key for the node.
     * @param options.publicKey - The public key for the node. If a private key is
     * specified, this parameter is ignored.
     * @param options.chainCode - The chain code for the node.
     * @param options.curve - The curve used by the node.
     * @param cryptographicFunctions - The cryptographic functions to use. If
     * provided, these will be used instead of the built-in implementations.
     * @returns A SLIP10 node.
     */
    static async fromExtendedKey(options, cryptographicFunctions) {
        if (typeof options === 'string') {
            const extendedKey = (0, extended_keys_1.decodeExtendedKey)(options);
            const { chainCode, depth, parentFingerprint, index } = extendedKey;
            if (extendedKey.type === 'private') {
                const { privateKey } = extendedKey;
                return _a.fromExtendedKey({
                    depth,
                    parentFingerprint,
                    index,
                    privateKey,
                    chainCode,
                    // BIP-32 key serialisation assumes `secp256k1`.
                    curve: 'secp256k1',
                }, cryptographicFunctions);
            }
            const { publicKey } = extendedKey;
            return _a.fromExtendedKey({
                depth,
                parentFingerprint,
                index,
                publicKey,
                chainCode,
                // BIP-32 key serialisation assumes `secp256k1`.
                curve: 'secp256k1',
            }, cryptographicFunctions);
        }
        const { depth, masterFingerprint, parentFingerprint, index, network, privateKey, publicKey, chainCode, curve, guard, } = options;
        const chainCodeBytes = (0, utils_2.getBytes)(chainCode, constants_1.BYTES_KEY_LENGTH);
        (0, utils_2.validateCurve)(curve);
        validateBIP32Depth(depth);
        (0, utils_2.validateBIP32Index)(index);
        validateRootIndex(index, depth);
        (0, utils_2.validateNetwork)(network);
        validateParentFingerprint(parentFingerprint, depth);
        validateMasterParentFingerprint(masterFingerprint, parentFingerprint, depth);
        const curveObject = (0, curves_1.getCurveByName)(curve);
        if (privateKey) {
            const privateKeyBytes = (0, utils_2.getBytesUnsafe)(privateKey, curveObject.privateKeyLength);
            (0, utils_1.assert)(curveObject.isValidPrivateKey(privateKeyBytes), `Invalid private key: Value is not a valid ${curve} private key.`);
            const trustedPublicKey = guard === guard_1.PUBLIC_KEY_GUARD && publicKey
                ? // `publicKey` is typed as `string | Uint8Array`, but we know it's
                    // a `Uint8Array` because of the guard. We use `getBytes` to ensure
                    // the type is correct.
                    (0, utils_2.getBytes)(publicKey, curveObject.publicKeyLength)
                : undefined;
            return new _a({
                depth,
                masterFingerprint,
                parentFingerprint,
                index,
                network,
                chainCode: chainCodeBytes,
                privateKey: privateKeyBytes,
                publicKey: trustedPublicKey,
                curve,
            }, cryptographicFunctions, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
        }
        if (publicKey) {
            const publicKeyBytes = (0, utils_2.getBytes)(publicKey, curveObject.publicKeyLength);
            return new _a({
                depth,
                masterFingerprint,
                parentFingerprint,
                index,
                network,
                chainCode: chainCodeBytes,
                publicKey: publicKeyBytes,
                curve,
            }, cryptographicFunctions, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
        }
        throw new Error('Invalid options: Must provide either a private key or a public key.');
    }
    /**
     * Create a new SLIP-10 node from a derivation path. The derivation path
     * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of
     * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of
     * BIP-39 seed phrase words.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param options - The options for the new node.
     * @param options.derivationPath - The rooted HD tree path that will be used
     * to derive the key of this node.
     * @param options.curve - The curve used by the node.
     * @param options.network - The network for the node. This is only used for
     * extended keys, and defaults to `mainnet`.
     * @param cryptographicFunctions - The cryptographic functions to use. If
     * provided, these will be used instead of the built-in implementations.
     * @returns A new SLIP-10 node.
     */
    static async fromDerivationPath({ derivationPath, network, curve }, cryptographicFunctions) {
        (0, utils_2.validateCurve)(curve);
        if (!derivationPath) {
            throw new Error('Invalid options: Must provide a derivation path.');
        }
        if (derivationPath.length === 0) {
            throw new Error('Invalid derivation path: May not specify an empty derivation path.');
        }
        // `deriveKeyFromPath` expects a seed derivation path, so we need to
        // convert the rooted path to a seed path.
        const seedDerivationPath = await (0, bip39_1.getDerivationPathWithSeed)({
            path: derivationPath,
            curve,
        }, cryptographicFunctions);
        return await (0, derivation_1.deriveKeyFromPath)({
            path: seedDerivationPath,
            depth: derivationPath.length - 1,
            network,
            curve,
        }, cryptographicFunctions);
    }
    /**
     * Create a new SLIP-10 node from a BIP-39 seed. The derivation path
     * must be rooted, i.e. it must begin with a BIP-39 node, given as a
     * `Uint8Array` of the seed bytes.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * @param options - The options for the new node.
     * @param options.derivationPath - The rooted HD tree path that will be used
     * to derive the key of this node.
     * @param options.curve - The curve used by the node.
     * @param options.network - The network for the node. This is only used for
     * extended keys, and defaults to `mainnet`.
     * @param cryptographicFunctions - The cryptographic functions to use. If
     * provided, these will be used instead of the built-in implementations.
     * @returns A new SLIP-10 node.
     */
    static async fromSeed({ derivationPath, network, curve }, cryptographicFunctions) {
        (0, utils_2.validateCurve)(curve);
        if (curve === 'ed25519Bip32') {
            throw new Error('Invalid curve: The curve "ed25519Bip32" is not supported by the `fromSeed` function.');
        }
        if (!derivationPath) {
            throw new Error('Invalid options: Must provide a derivation path.');
        }
        if (derivationPath.length === 0) {
            throw new Error('Invalid derivation path: May not specify an empty derivation path.');
        }
        return await (0, derivation_1.deriveKeyFromPath)({
            path: derivationPath,
            depth: derivationPath.length - 1,
            network,
            curve,
        }, cryptographicFunctions);
    }
    // eslint-disable-next-line no-restricted-syntax
    constructor({ depth, masterFingerprint, parentFingerprint, index, network = 'mainnet', chainCode, privateKey, publicKey, curve, }, cryptographicFunctions = {}, constructorGuard) {
        _SLIP10Node_publicKeyBytes.set(this, void 0);
        _SLIP10Node_cryptographicFunctions.set(this, void 0);
        (0, utils_1.assert)(constructorGuard === __classPrivateFieldGet(_a, _a, "f", _SLIP10Node_constructorGuard), 'SLIP10Node can only be constructed using `SLIP10Node.fromJSON`, `SLIP10Node.fromExtendedKey`, `SLIP10Node.fromDerivationPath`, or `SLIP10Node.fromSeed`.');
        (0, utils_1.assert)(privateKey !== undefined || publicKey !== undefined, 'SLIP10Node requires either a private key or a public key to be set.');
        this.depth = depth;
        this.masterFingerprint = masterFingerprint;
        this.parentFingerprint = parentFingerprint;
        this.index = index;
        this.network = network;
        this.chainCodeBytes = chainCode;
        this.privateKeyBytes = privateKey;
        this.curve = curve;
        __classPrivateFieldSet(this, _SLIP10Node_publicKeyBytes, publicKey, "f");
        __classPrivateFieldSet(this, _SLIP10Node_cryptographicFunctions, cryptographicFunctions, "f");
        Object.freeze(this);
    }
    get chainCode() {
        return (0, utils_1.bytesToHex)(this.chainCodeBytes);
    }
    get privateKey() {
        if (this.privateKeyBytes) {
            return (0, utils_1.bytesToHex)(this.privateKeyBytes);
        }
        return undefined;
    }
    get publicKey() {
        return (0, utils_1.bytesToHex)(this.publicKeyBytes);
    }
    /**
     * Get the public key bytes. This will lazily derive the public key from the
     * private key if it is not already set.
     *
     * @returns The public key bytes.
     */
    get publicKeyBytes() {
        if (__classPrivateFieldGet(this, _SLIP10Node_publicKeyBytes, "f") !== undefined) {
            return __classPrivateFieldGet(this, _SLIP10Node_publicKeyBytes, "f");
        }
        // This assertion is mainly for type safety, as `SLIP10Node` requires either
        // a private key or a public key to always be set.
        (0, utils_1.assert)(this.privateKeyBytes, 'Either a private key or public key is required.');
        __classPrivateFieldSet(this, _SLIP10Node_publicKeyBytes, (0, curves_1.getCurveByName)(this.curve).getPublicKey(this.privateKeyBytes), "f");
        return __classPrivateFieldGet(this, _SLIP10Node_publicKeyBytes, "f");
    }
    get compressedPublicKeyBytes() {
        return (0, curves_1.getCurveByName)(this.curve).compressPublicKey(this.publicKeyBytes);
    }
    get compressedPublicKey() {
        return (0, utils_1.bytesToHex)(this.compressedPublicKeyBytes);
    }
    get address() {
        if (this.curve !== 'secp256k1') {
            throw new Error('Unable to get address for this node: Only secp256k1 is supported.');
        }
        return (0, utils_1.bytesToHex)((0, bip32_1.publicKeyToEthAddress)(this.publicKeyBytes));
    }
    get fingerprint() {
        return (0, utils_2.getFingerprint)(this.compressedPublicKeyBytes, (0, curves_1.getCurveByName)(this.curve).compressedPublicKeyLength);
    }
    /**
     * Get the extended public or private key for the SLIP-10 node. SLIP-10
     * doesn't specify a format for extended keys, so we use the BIP-32 format.
     *
     * This property is only supported for `secp256k1` nodes, as other curves
     * don't specify a standard format for extended keys.
     *
     * @returns The extended public or private key for the node.
     */
    get extendedKey() {
        (0, utils_1.assert)(this.curve === 'secp256k1', 'Unable to get extended key for this node: Only secp256k1 is supported.');
        const data = {
            depth: this.depth,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            network: this.network,
            chainCode: this.chainCodeBytes,
        };
        if (this.privateKeyBytes) {
            return (0, extended_keys_1.encodeExtendedKey)({
                ...data,
                type: 'private',
                privateKey: this.privateKeyBytes,
            });
        }
        return (0, extended_keys_1.encodeExtendedKey)({
            ...data,
            type: 'public',
            publicKey: this.publicKeyBytes,
        });
    }
    /**
     * Get a neutered version of this node, i.e. a node without a private key.
     *
     * @returns A neutered version of this node.
     */
    neuter() {
        return new _a({
            depth: this.depth,
            masterFingerprint: this.masterFingerprint,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            chainCode: this.chainCodeBytes,
            publicKey: this.publicKeyBytes,
            curve: this.curve,
            network: this.network,
        }, __classPrivateFieldGet(this, _SLIP10Node_cryptographicFunctions, "f"), __classPrivateFieldGet(_a, _a, "f", _SLIP10Node_constructorGuard));
    }
    /**
     * Derives a child of the key contains be this node and returns a new
     * {@link SLIP10Node} containing the child key.
     *
     * The specified path must be a valid HD path from this node, per SLIP-10.
     *
     * @param path - The partial (non-rooted) SLIP-10 HD tree path will be used
     * to derive a child key from the parent key contained within this node.
     * @returns The {@link SLIP10Node} corresponding to the derived child key.
     */
    async derive(path) {
        return await deriveChildNode({
            path,
            node: this,
        }, __classPrivateFieldGet(this, _SLIP10Node_cryptographicFunctions, "f"));
    }
    // This is documented in the interface of this class.
    toJSON() {
        return {
            depth: this.depth,
            masterFingerprint: this.masterFingerprint,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            network: this.network,
            curve: this.curve,
            privateKey: this.privateKey,
            publicKey: this.publicKey,
            chainCode: this.chainCode,
        };
    }
}
exports.SLIP10Node = SLIP10Node;
_a = SLIP10Node, _SLIP10Node_publicKeyBytes = new WeakMap(), _SLIP10Node_cryptographicFunctions = new WeakMap();
_SLIP10Node_constructorGuard = { value: Symbol('SLIP10Node.constructor') };
/**
 * Validates a BIP-32 path depth. Effectively, asserts that the depth is an
 * integer `number`. Throws an error if validation fails.
 *
 * @param depth - The depth to validate.
 */
function validateBIP32Depth(depth) {
    if (!(0, utils_2.isValidInteger)(depth)) {
        throw new Error(`Invalid HD tree path depth: The depth must be a positive integer. Received: "${String(depth)}".`);
    }
}
exports.validateBIP32Depth = validateBIP32Depth;
/**
 * Validates a BIP-32 parent fingerprint. Effectively, asserts that the fingerprint is an
 * integer `number`. Throws an error if validation fails.
 *
 * @param parentFingerprint - The parent fingerprint to validate.
 * @param depth - The depth of the node to validate.
 * @throws If the parent fingerprint is not a positive integer, or invalid for
 * the current depth.
 */
function validateParentFingerprint(parentFingerprint, depth) {
    if (!(0, utils_2.isValidInteger)(parentFingerprint)) {
        throw new Error(`Invalid parent fingerprint: The fingerprint must be a positive integer. Received: "${String(parentFingerprint)}".`);
    }
    if (depth === 0 && parentFingerprint !== 0) {
        throw new Error(`Invalid parent fingerprint: The fingerprint of the root node must be 0. Received: "${String(parentFingerprint)}".`);
    }
    if (depth > 0 && parentFingerprint === 0) {
        throw new Error(`Invalid parent fingerprint: The fingerprint of a child node must not be 0. Received: "${String(parentFingerprint)}".`);
    }
}
exports.validateParentFingerprint = validateParentFingerprint;
/**
 * Validate that a given combination of master fingerprint and parent
 * fingerprint is valid for the given depth.
 *
 * @param masterFingerprint - The master fingerprint to validate.
 * @param parentFingerprint - The parent fingerprint to validate.
 * @param depth - The depth of the node to validate.
 * @throws If the combination of master fingerprint and parent fingerprint is
 * invalid for the given depth.
 */
function validateMasterParentFingerprint(masterFingerprint, parentFingerprint, depth) {
    // The master fingerprint is optional.
    if (!masterFingerprint) {
        return;
    }
    if (depth >= 2 && masterFingerprint === parentFingerprint) {
        throw new Error(`Invalid parent fingerprint: The fingerprint of a child node cannot be equal to the master fingerprint. Received: "${String(parentFingerprint)}".`);
    }
}
exports.validateMasterParentFingerprint = validateMasterParentFingerprint;
/**
 * Validate that the index is zero for the root node.
 *
 * @param index - The index to validate.
 * @param depth - The depth of the node to validate.
 * @throws If the index is not zero for the root node.
 */
function validateRootIndex(index, depth) {
    if (depth === 0 && index !== 0) {
        throw new Error(`Invalid index: The index of the root node must be 0. Received: "${String(index)}".`);
    }
}
exports.validateRootIndex = validateRootIndex;
/**
 * Derives a child key from the given parent key.
 *
 * @param options - The options to use when deriving the child key.
 * @param options.node - The node to derive from.
 * @param options.path - The path to the child node / key.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The derived key and depth.
 */
async function deriveChildNode({ path, node }, cryptographicFunctions) {
    if (path.length === 0) {
        throw new Error('Invalid HD tree derivation path: Deriving a path of length 0 is not defined.');
    }
    // Note that we do not subtract 1 from the length of the path to the child,
    // unlike when we calculate the depth of a rooted path.
    const newDepth = node.depth + path.length;
    validateBIP32Depth(newDepth);
    return await (0, derivation_1.deriveKeyFromPath)({
        path,
        node,
        depth: newDepth,
    }, cryptographicFunctions);
}
exports.deriveChildNode = deriveChildNode;
//# sourceMappingURL=SLIP10Node.cjs.map