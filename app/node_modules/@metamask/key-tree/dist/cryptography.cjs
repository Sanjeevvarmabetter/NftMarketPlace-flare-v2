"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha256 = exports.ripemd160 = exports.pbkdf2Sha512 = exports.keccak256 = exports.hmacSha512 = void 0;
const hmac_1 = require("@noble/hashes/hmac");
const pbkdf2_1 = require("@noble/hashes/pbkdf2");
const ripemd160_1 = require("@noble/hashes/ripemd160");
const sha256_1 = require("@noble/hashes/sha256");
const sha3_1 = require("@noble/hashes/sha3");
const sha512_1 = require("@noble/hashes/sha512");
const utils_1 = require("./utils.cjs");
/**
 * Compute the HMAC-SHA-512 of the given data using the given key.
 *
 * This function uses the Web Crypto API if available, falling back to a
 * JavaScript implementation if not.
 *
 * @param key - The key to use.
 * @param data - The data to hash.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The HMAC-SHA-512 of the data.
 */
async function hmacSha512(key, data, cryptographicFunctions = {}) {
    if (cryptographicFunctions.hmacSha512) {
        return await cryptographicFunctions.hmacSha512(key, data);
    }
    if ((0, utils_1.isWebCryptoSupported)()) {
        /* eslint-disable no-restricted-globals */
        const subtleKey = await crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: 'SHA-512' }, false, ['sign']);
        const result = await crypto.subtle.sign('HMAC', subtleKey, data);
        return new Uint8Array(result);
        /* eslint-enable no-restricted-globals */
    }
    return (0, hmac_1.hmac)(sha512_1.sha512, key, data);
}
exports.hmacSha512 = hmacSha512;
/**
 * Compute the Keccak-256 of the given data synchronously.
 *
 * Right now this is just a wrapper around `keccak256` from the `@noble/hashes`
 * package, but it's here in case we want to change the implementation in the
 * future to allow for asynchronous hashing.
 *
 * @param data - The data to hash.
 * @returns The Keccak-256 of the data.
 */
function keccak256(data) {
    return (0, sha3_1.keccak_256)(data);
}
exports.keccak256 = keccak256;
/**
 * Compute the PBKDF2 of the given password, salt, iterations, and key length.
 * The hash function used is SHA-512.
 *
 * @param password - The password to hash.
 * @param salt - The salt to use.
 * @param iterations - The number of iterations.
 * @param keyLength - The desired key length.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The PBKDF2 of the password.
 */
async function pbkdf2Sha512(password, salt, iterations, keyLength, cryptographicFunctions = {}) {
    if (cryptographicFunctions.pbkdf2Sha512) {
        return await cryptographicFunctions.pbkdf2Sha512(password, salt, iterations, keyLength);
    }
    if ((0, utils_1.isWebCryptoSupported)()) {
        /* eslint-disable no-restricted-globals */
        const key = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveBits']);
        const derivedBits = await crypto.subtle.deriveBits({
            name: 'PBKDF2',
            salt,
            iterations,
            hash: { name: 'SHA-512' },
        }, key, 
        // `keyLength` is the number of bytes, but `deriveBits` expects the
        // number of bits, so we multiply by 8.
        keyLength * 8);
        return new Uint8Array(derivedBits);
        /* eslint-enable no-restricted-globals */
    }
    return await (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, password, salt, {
        c: iterations,
        dkLen: keyLength,
    });
}
exports.pbkdf2Sha512 = pbkdf2Sha512;
/**
 * Compute the RIPEMD-160 of the given data.
 *
 * Right now this is just a wrapper around `ripemd160` from the `@noble/hashes`
 * package, but it's here in case we want to change the implementation in the
 * future to allow for asynchronous hashing.
 *
 * @param data - The data to hash.
 * @returns The RIPEMD-160 of the data.
 */
function ripemd160(data) {
    return (0, ripemd160_1.ripemd160)(data);
}
exports.ripemd160 = ripemd160;
/**
 * Compute the SHA-256 of the given data synchronously.
 *
 * Right now this is just a wrapper around `sha256` from the `@noble/hashes`
 * package, but it's here in case we want to change the implementation in the
 * future to allow for asynchronous hashing.
 *
 * @param data - The data to hash.
 * @returns The SHA-256 of the data.
 */
function sha256(data) {
    return (0, sha256_1.sha256)(data);
}
exports.sha256 = sha256;
//# sourceMappingURL=cryptography.cjs.map