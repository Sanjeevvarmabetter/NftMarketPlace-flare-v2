{"version":3,"file":"utils.cjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":";;;AAAA,6EAA2F;AAC3F,2CAAqE;AACrE,sCAA8D;AAM9D,+DAA6D;AAW7D,+CAKqB;AACrB,qDAAmD;AAEnD,+CAAkC;AAElC;;;;;;;;GAQG;AACH,SAAgB,0BAA0B,CACxC,SAAiB;IAEjB,OAAO,OAAO,iCAAqB,MAAM,yBAAyB,CAChE,SAAS,CACV,EAAE,CAAC;AACN,CAAC;AAND,gEAMC;AAgBD;;;;;;;;;;GAUG;AACH,SAAgB,wBAAwB,CACtC,YAAkC,EAClC,OAAwD;IAExD,OAAO,GAAG,YAAY,MAAM,yBAAyB,CACnD,OAAO,CAAC,OAAO,IAAI,CAAC,CACrB,MAAM,iBAAiB,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,CAAC,EAAE,CAAC;AAClD,CAAC;AAPD,4DAOC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,kCAAkC,CAAC,EACjD,OAAO,GAAG,CAAC,EACX,MAAM,GAAG,CAAC,EACV,aAAa,GACY;IACzB,OAAO;QACL,yBAAyB,CAAC,OAAO,CAAC;QAClC,iBAAiB,CAAC,MAAM,CAAC;QACzB,iBAAiB,CAAC,aAAa,CAAC;KACxB,CAAC;AACb,CAAC;AAVD,gFAUC;AAED;;;;;;;GAOG;AACH,SAAgB,yBAAyB,CAAC,KAAa;IACrD,kBAAkB,CAAC,KAAK,CAAC,CAAC;IAC1B,OAAO,GAAG,2BAA2B,CAAC,KAAK,CAAC,GAAG,CAAC;AAClD,CAAC;AAHD,8DAGC;AAED;;;;;;;GAOG;AACH,SAAgB,2BAA2B,CACzC,KAAa;IAEb,kBAAkB,CAAC,KAAK,CAAC,CAAC;IAC1B,OAAO,SAAS,KAAK,EAAE,CAAC;AAC1B,CAAC;AALD,kEAKC;AAED;;;;;;;GAOG;AACH,SAAgB,iBAAiB,CAAC,KAAqB;IACrD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,OAAO,2BAA2B,CAAC,KAAK,CAAC,CAAC;IAC5C,CAAC;IAED,IACE,CAAC,KAAK;QACN,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC;QAC9B,OAAO,KAAK,CAAC,QAAQ,KAAK,SAAS,EACnC,CAAC;QACD,MAAM,IAAI,KAAK,CACb,0FAA0F,CAC3F,CAAC;IACJ,CAAC;IAED,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;QACnB,OAAO,yBAAyB,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;IAChD,CAAC;IAED,OAAO,2BAA2B,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAClD,CAAC;AApBD,8CAoBC;AAED;;;;;GAKG;AACH,SAAgB,kBAAkB,CAAC,YAAoB;IACrD,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,EAAE,CAAC;QACrC,MAAM,IAAI,KAAK,CAAC,uDAAuD,CAAC,CAAC;IAC3E,CAAC;AACH,CAAC;AAJD,gDAIC;AAED;;;;;GAKG;AACH,SAAgB,iBAAiB,CAAC,KAAa;IAC7C,OAAO,cAAc,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,4BAAgB,CAAC;AAC5D,CAAC;AAFD,8CAEC;AAED;;;;;;GAMG;AACH,SAAgB,uBAAuB,CACrC,OAAe;IAEf,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,wCAA4B,CAAC,CAAC;IAC1D,IAAI,OAAO,KAAK,EAAE,MAAM,EAAE,KAAK,KAAK,WAAW,EAAE,CAAC;QAChD,OAAO,KAAK,CAAC;IACf,CAAC;IAED,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IAC/C,OAAO,cAAc,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,uCAA2B,CAAC;AACvE,CAAC;AAdD,0DAcC;AAED;;;;;;;GAOG;AACH,SAAgB,UAAU,CAAC,UAAkB;IAC3C,OAAO,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;AAClC,CAAC;AAFD,gCAEC;AAED;;;;;;;GAOG;AACH,SAAgB,gBAAgB,CAAC,SAA8B;IAC7D,IAAI,SAAS,YAAY,UAAU,EAAE,CAAC;QACpC,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,OAAO,IAAA,kBAAU,EAAC,SAAS,CAAC,CAAC;AAC/B,CAAC;AAND,4CAMC;AAED;;;;;;GAMG;AACH,SAAgB,wBAAwB,CACtC,SAA+B;IAE/B,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;QAC5B,OAAO,gBAAgB,CAAC,SAAS,CAAC,CAAC;IACrC,CAAC;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AARD,4DAQC;AAED;;;;;;;GAOG;AACH,SAAgB,eAAe,CAC7B,KAAiB,EACjB,cAAsB;IAEtB,IAAI,KAAK,CAAC,MAAM,KAAK,cAAc,EAAE,CAAC;QACpC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,IAAI,IAAI,KAAK,CAAC,EAAE,CAAC;YACf,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAdD,0CAcC;AAED;;;;;GAKG;AACH,SAAgB,cAAc,CAAC,KAAc;IAC3C,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;AAC5E,CAAC;AAFD,wCAEC;AAED;;;;;;;;GAQG;AACH,SAAgB,QAAQ,CAAC,KAAc,EAAE,MAAc;IACrD,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;QAChC,aAAa,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAE7B,OAAO,KAAK,CAAC;IACf,CAAC;IAED,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,MAAM,KAAK,GAAG,IAAA,kBAAU,EAAC,KAAK,CAAC,CAAC;QAChC,aAAa,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAE7B,OAAO,KAAK,CAAC;IACf,CAAC;IAED,MAAM,IAAI,KAAK,CACb,0EAA0E,CAC3E,CAAC;AACJ,CAAC;AAjBD,4BAiBC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,cAAc,CAAC,KAAc,EAAE,MAAc;IAC3D,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;QAChC,IAAA,cAAM,EACJ,KAAK,CAAC,MAAM,KAAK,MAAM,EACvB,4BAA4B,MAAM,mBAAmB,CACtD,CAAC;QACF,OAAO,KAAK,CAAC;IACf,CAAC;IAED,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,OAAO,cAAc,CAAC,IAAA,kBAAU,EAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;IACnD,CAAC;IAED,MAAM,IAAI,KAAK,CACb,0EAA0E,CAC3E,CAAC;AACJ,CAAC;AAhBD,wCAgBC;AAED;;;;;;;GAOG;AACH,SAAgB,aAAa,CAC3B,KAAiB,EACjB,MAAc;IAEd,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,CAAC;QACpC,MAAM,IAAI,KAAK,CACb,qCAAqC,MAAM,mBAAmB,CAC/D,CAAC;IACJ,CAAC;AACH,CAAC;AATD,sCASC;AAEM,MAAM,iBAAiB,GAAG,CAAC,KAAa,EAAc,EAAE;IAC7D,MAAM,WAAW,GAAG,IAAA,kBAAgB,EAAC,qBAAM,CAAC,CAAC;IAE7C,IAAI,CAAC;QACH,OAAO,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACnC,CAAC;IAAC,MAAM,CAAC;QACP,MAAM,IAAI,KAAK,CACb,gFAAgF,CACjF,CAAC;IACJ,CAAC;AACH,CAAC,CAAC;AAVW,QAAA,iBAAiB,qBAU5B;AAEK,MAAM,iBAAiB,GAAG,CAAC,KAAiB,EAAU,EAAE;IAC7D,MAAM,WAAW,GAAG,IAAA,kBAAgB,EAAC,qBAAM,CAAC,CAAC;IAE7C,OAAO,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACnC,CAAC,CAAC;AAJW,QAAA,iBAAiB,qBAI5B;AAEF;;;;;;GAMG;AACI,MAAM,cAAc,GAAG,CAC5B,SAAqB,EACrB,yBAAiC,EACzB,EAAE;IACV,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,yBAAyB,CAAC,EAAE,CAAC;QAC3D,MAAM,IAAI,KAAK,CACb,yCAAyC,yBAAyB,6BAA6B,CAChG,CAAC;IACJ,CAAC;IAED,MAAM,KAAK,GAAG,IAAA,wBAAS,EAAC,IAAA,qBAAM,EAAC,SAAS,CAAC,CAAC,CAAC;IAC3C,MAAM,IAAI,GAAG,IAAA,sBAAc,EAAC,KAAK,CAAC,CAAC;IAEnC,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;AAClC,CAAC,CAAC;AAdW,QAAA,cAAc,kBAczB;AAEF;;;;;;;;;GASG;AACH,SAAgB,qBAAqB,CAAC,cAAsB;IAC1D,MAAM,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACxC,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;QACjC,MAAM,KAAK,GAAG,kBAAe,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC5C,IAAA,cAAM,EAAC,KAAK,KAAK,CAAC,CAAC,EAAE,0CAA0C,IAAI,IAAI,CAAC,CAAC;QAEzE,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;IAEH,OAAO,IAAI,UAAU,CAAC,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC;AACzD,CAAC;AAVD,sDAUC;AAED;;;;GAIG;AACH,SAAgB,aAAa,CAC3B,SAAkB;IAElB,IAAI,CAAC,SAAS,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE,CAAC;QAChD,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;IAC1D,CAAC;IAED,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,eAAM,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,CAAC;QAC7C,MAAM,IAAI,KAAK,CACb,2DAA2D,MAAM,CAAC,IAAI,CACpE,eAAM,CACP,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAChB,CAAC;IACJ,CAAC;AACH,CAAC;AAdD,sCAcC;AAED;;;;;;GAMG;AACH,SAAgB,cAAc,CAC5B,KAAa,EACb,YAAY,GAAG,KAAK;IAEpB,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;IAChC,MAAM,IAAI,GAAG,IAAA,sBAAc,EAAC,KAAK,CAAC,CAAC;IAEnC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC;IAEvC,OAAO,KAAK,CAAC;AACf,CAAC;AAVD,wCAUC;AAED;;;;;GAKG;AACH,SAAgB,oBAAoB;IAClC,OAAO,OAAO,CAAC,UAAU,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAC5C,CAAC;AAFD,oDAEC;AAED;;;;;;;GAOG;AACH,SAAgB,eAAe,CAC7B,OAAgB;IAEhB,IAAI,OAAO,KAAK,SAAS,EAAE,CAAC;QAC1B,OAAO;IACT,CAAC;IAED,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;QAChC,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;IACrE,CAAC;IAED,IAAI,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC;QAC9C,MAAM,IAAI,KAAK,CACb,sEAAsE,CACvE,CAAC;IACJ,CAAC;AACH,CAAC;AAhBD,0CAgBC;AAED;;;;;;;;;GASG;AACH,SAAgB,gBAAgB,CAC9B,cAA2D;IAE3D,MAAM,QAAQ,GAAG,cAAc,CAAC,0CAAsB,CAAC,CAAC,KAAK,CAC3D,GAAG,CACJ,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;IAEvB,IAAA,cAAM,EAAC,QAAQ,EAAE,sDAAsD,CAAC,CAAC;IAEzE,MAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;IAC5C,IAAA,cAAM,EACJ,cAAc,CAAC,KAAK,CAAC,EACrB,4DAA4D,CAC7D,CAAC;IAEF,OAAO,KAAK,CAAC;AACf,CAAC;AAhBD,4CAgBC","sourcesContent":["import { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert, createDataView, hexToBytes } from '@metamask/utils';\nimport { base58check as scureBase58check } from '@scure/base';\n\nimport type {\n  CoinTypeHDPathTuple,\n  CoinTypeSeedPathTuple,\n} from './BIP44CoinTypeNode';\nimport { BIP_44_COIN_TYPE_DEPTH } from './BIP44CoinTypeNode';\nimport type {\n  BIP32Node,\n  ChangeHDPathString,\n  CoinTypeHDPathString,\n  CoinTypeToAddressTuple,\n  HardenedBIP32Node,\n  Network,\n  UnhardenedBIP32Node,\n  UnprefixedNode,\n} from './constants';\nimport {\n  BIP44PurposeNodeToken,\n  MAX_BIP_32_INDEX,\n  MAX_UNHARDENED_BIP_32_INDEX,\n  UNPREFIXED_BIP_32_PATH_REGEX,\n} from './constants';\nimport { ripemd160, sha256 } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { curves } from './curves';\n\n/**\n * Gets a string representation of a BIP-44 path of depth 2, i.e.:\n * `m / 44' / coin_type'`\n *\n * For display purposes only.\n *\n * @param coin_type - The `coin_type` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for thte specified `coin_type`.\n */\nexport function getBIP44CoinTypePathString(\n  coin_type: number,\n): CoinTypeHDPathString {\n  return `m / ${BIP44PurposeNodeToken} / ${getHardenedBIP32NodeToken(\n    coin_type,\n  )}`;\n}\n\ntype BIP44PathIndex = number | { index: number; hardened: boolean };\n\ntype BIP44PathIndices = {\n  coin_type: number;\n  account?: number;\n  change?: BIP44PathIndex;\n  address_index: BIP44PathIndex;\n};\n\nexport type CoinTypeToAddressIndices = Pick<\n  BIP44PathIndices,\n  'account' | 'change' | 'address_index'\n>;\n\n/**\n * Gets a string representation of a BIP-44 path of depth 4, i.e.:\n * `m / 44' / coin_type' / account' / change`\n *\n * For display purposes only.\n *\n * @param coinTypePath - The parent `coin_type` path.\n * @param indices - The `account` and `change` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for the specified `coin_type`\n * and `change` indices.\n */\nexport function getBIP44ChangePathString(\n  coinTypePath: CoinTypeHDPathString,\n  indices: Omit<CoinTypeToAddressIndices, 'address_index'>,\n): ChangeHDPathString {\n  return `${coinTypePath} / ${getHardenedBIP32NodeToken(\n    indices.account ?? 0,\n  )} / ${getBIP32NodeToken(indices.change ?? 0)}`;\n}\n\n/**\n * Gets a BIP-44 path tuple of the form `account' / change / address_index`,\n * which can be used to derive address keys together with a `coin_type` key.\n *\n * @param indices - The BIP-44 derivation index values.\n * @param indices.account - The `account` index value.\n * @param indices.change - The `change` index value.\n * @param indices.address_index - The `address_index` index value.\n * @returns The `account' / change / address_index` path corresponding to the\n * specified indices.\n */\nexport function getBIP44CoinTypeToAddressPathTuple({\n  account = 0,\n  change = 0,\n  address_index,\n}: CoinTypeToAddressIndices): CoinTypeToAddressTuple {\n  return [\n    getHardenedBIP32NodeToken(account),\n    getBIP32NodeToken(change),\n    getBIP32NodeToken(address_index),\n  ] as const;\n}\n\n/**\n * A hardened BIP-32 node token, e.g. `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened BIP-32 node token.\n */\nexport function getHardenedBIP32NodeToken(index: number): HardenedBIP32Node {\n  validateBIP32Index(index);\n  return `${getUnhardenedBIP32NodeToken(index)}'`;\n}\n\n/**\n * An unhardened BIP-32 node token, e.g. `bip32:0`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The unhardened BIP-32 node token.\n */\nexport function getUnhardenedBIP32NodeToken(\n  index: number,\n): UnhardenedBIP32Node {\n  validateBIP32Index(index);\n  return `bip32:${index}`;\n}\n\n/**\n * A hardened or unhardened BIP-32 node token, e.g. `bip32:0` or `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened or unhardened BIP-32 node token.\n */\nexport function getBIP32NodeToken(index: BIP44PathIndex): BIP32Node {\n  if (typeof index === 'number') {\n    return getUnhardenedBIP32NodeToken(index);\n  }\n\n  if (\n    !index ||\n    !Number.isInteger(index.index) ||\n    typeof index.hardened !== 'boolean'\n  ) {\n    throw new Error(\n      'Invalid BIP-32 index: Must be an object containing the index and whether it is hardened.',\n    );\n  }\n\n  if (index.hardened) {\n    return getHardenedBIP32NodeToken(index.index);\n  }\n\n  return getUnhardenedBIP32NodeToken(index.index);\n}\n\n/**\n * Validates that the index is a non-negative integer number. Throws an\n * error if validation fails.\n *\n * @param addressIndex - The index to validate.\n */\nexport function validateBIP32Index(addressIndex: number): void {\n  if (!isValidBIP32Index(addressIndex)) {\n    throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);\n  }\n}\n\n/**\n * Check if the index is a valid BIP-32 index.\n *\n * @param index - The BIP-32 index to test.\n * @returns Whether the index is a non-negative integer number.\n */\nexport function isValidBIP32Index(index: number): boolean {\n  return isValidInteger(index) && index <= MAX_BIP_32_INDEX;\n}\n\n/**\n * Check if the value is a valid BIP-32 path segment, i.e., a string of the form\n * `0'`.\n *\n * @param segment - The BIP-32 path segment to test.\n * @returns Whether the path segment is a valid BIP-32 path segment.\n */\nexport function isValidBIP32PathSegment(\n  segment: string,\n): segment is UnprefixedNode {\n  if (typeof segment !== 'string') {\n    return false;\n  }\n\n  const match = segment.match(UNPREFIXED_BIP_32_PATH_REGEX);\n  if (typeof match?.groups?.index === 'undefined') {\n    return false;\n  }\n\n  const index = parseInt(match.groups.index, 10);\n  return isValidInteger(index) && index <= MAX_UNHARDENED_BIP_32_INDEX;\n}\n\n/**\n * Check if the value is a hardened BIP-32 index. This only checks if the value\n * ends with a `'` character, and does not validate that the index is a valid\n * BIP-32 index.\n *\n * @param bip32Token - The token to test.\n * @returns Whether the token is hardened, i.e. ends with `'`.\n */\nexport function isHardened(bip32Token: string): boolean {\n  return bip32Token.endsWith(`'`);\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or a `Uint8Array`. If the input\n * is a hexadecimal string, it is converted to a `Uint8Array`. If the input is\n * a `Uint8Array`, it is returned as-is.\n *\n * @param hexString - The hexadecimal string to convert.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function hexStringToBytes(hexString: string | Uint8Array): Uint8Array {\n  if (hexString instanceof Uint8Array) {\n    return hexString;\n  }\n\n  return hexToBytes(hexString);\n}\n\n/**\n * The same as {@link hexStringToBytes}, but returns `undefined` if the input\n * is `undefined`.\n *\n * @param hexString - The hexadecimal string to convert.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function nullableHexStringToBytes(\n  hexString?: string | Uint8Array,\n): Uint8Array | undefined {\n  if (hexString !== undefined) {\n    return hexStringToBytes(hexString);\n  }\n\n  return undefined;\n}\n\n/**\n * Tests whether the specified `Uint8Array` is a valid BIP-32 key.\n * A valid bytes key is 64 bytes long and has at least one non-zero byte.\n *\n * @param bytes - The `Uint8Array` to test.\n * @param expectedLength - The expected length of the Uint8Array.\n * @returns Whether the Uint8Array represents a valid BIP-32 key.\n */\nexport function isValidBytesKey(\n  bytes: Uint8Array,\n  expectedLength: number,\n): boolean {\n  if (bytes.length !== expectedLength) {\n    return false;\n  }\n\n  for (const byte of bytes) {\n    if (byte !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Tests whether the specified number is a valid integer equal to or greater than 0.\n *\n * @param value - The number to test.\n * @returns Whether the number is a valid integer.\n */\nexport function isValidInteger(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that the\n * length of the `Uint8Array` matches the specified length, and that the `Uint8Array`\n * is not empty.\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param length - The length to validate the `Uint8Array` against.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function getBytes(value: unknown, length: number): Uint8Array {\n  if (value instanceof Uint8Array) {\n    validateBytes(value, length);\n\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const bytes = hexToBytes(value);\n    validateBytes(bytes, length);\n\n    return bytes;\n  }\n\n  throw new Error(\n    `Invalid value: Expected an instance of Uint8Array or hexadecimal string.`,\n  );\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that\n * the length of the `Uint8Array` matches the specified length.\n *\n * This function is \"unsafe,\" in the sense that it does not validate that the\n * `Uint8Array` is not empty (i.e., all bytes are zero).\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param length - The length to validate the `Uint8Array` against.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function getBytesUnsafe(value: unknown, length: number): Uint8Array {\n  if (value instanceof Uint8Array) {\n    assert(\n      value.length === length,\n      `Invalid value: Must be a ${length}-byte byte array.`,\n    );\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return getBytesUnsafe(hexToBytes(value), length);\n  }\n\n  throw new Error(\n    `Invalid value: Expected an instance of Uint8Array or hexadecimal string.`,\n  );\n}\n\n/**\n * Validate that the specified `Uint8Array` is not empty and has the specified\n * length.\n *\n * @param bytes - The `Uint8Array` to validate.\n * @param length - The length to validate the `Uint8Array` against.\n * @throws An error if the `Uint8Array` is empty or has the wrong length.\n */\nexport function validateBytes(\n  bytes: Uint8Array,\n  length: number,\n): asserts bytes is Uint8Array {\n  if (!isValidBytesKey(bytes, length)) {\n    throw new Error(\n      `Invalid value: Must be a non-zero ${length}-byte byte array.`,\n    );\n  }\n}\n\nexport const decodeBase58check = (value: string): Uint8Array => {\n  const base58Check = scureBase58check(sha256);\n\n  try {\n    return base58Check.decode(value);\n  } catch {\n    throw new Error(\n      `Invalid extended key: Value is not base58-encoded, or the checksum is invalid.`,\n    );\n  }\n};\n\nexport const encodeBase58check = (value: Uint8Array): string => {\n  const base58Check = scureBase58check(sha256);\n\n  return base58Check.encode(value);\n};\n\n/**\n * Get the fingerprint of a compressed public key as number.\n *\n * @param publicKey - The compressed public key to get the fingerprint for.\n * @param compressedPublicKeyLength - The length of the compressed public key.\n * @returns The fingerprint of the public key.\n */\nexport const getFingerprint = (\n  publicKey: Uint8Array,\n  compressedPublicKeyLength: number,\n): number => {\n  if (!isValidBytesKey(publicKey, compressedPublicKeyLength)) {\n    throw new Error(\n      `Invalid public key: The key must be a ${compressedPublicKeyLength}-byte, non-zero byte array.`,\n    );\n  }\n\n  const bytes = ripemd160(sha256(publicKey));\n  const view = createDataView(bytes);\n\n  return view.getUint32(0, false);\n};\n\n/**\n * Get a secret recovery phrase (or mnemonic phrase) in string form as a\n * `Uint8Array`. The secret recovery phrase is split into words, and each word\n * is converted to a number using the BIP-39 word list. The numbers are then\n * converted to bytes, and the bytes are concatenated into a single\n * `Uint8Array`.\n *\n * @param mnemonicPhrase - The secret recovery phrase to convert.\n * @returns The `Uint8Array` corresponding to the secret recovery phrase.\n */\nexport function mnemonicPhraseToBytes(mnemonicPhrase: string): Uint8Array {\n  const words = mnemonicPhrase.split(' ');\n  const indices = words.map((word) => {\n    const index = englishWordlist.indexOf(word);\n    assert(index !== -1, `Invalid mnemonic phrase: Unknown word \"${word}\".`);\n\n    return index;\n  });\n\n  return new Uint8Array(new Uint16Array(indices).buffer);\n}\n\n/**\n * Validates the curve name.\n *\n * @param curveName - The name of the curve to validate.\n */\nexport function validateCurve(\n  curveName: unknown,\n): asserts curveName is SupportedCurve {\n  if (!curveName || typeof curveName !== 'string') {\n    throw new Error('Invalid curve: Must specify a curve.');\n  }\n\n  if (!Object.keys(curves).includes(curveName)) {\n    throw new Error(\n      `Invalid curve: Only the following curves are supported: ${Object.keys(\n        curves,\n      ).join(', ')}.`,\n    );\n  }\n}\n\n/**\n * Get a 4-byte-long `Uint8Array` from a numeric value.\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param littleEndian - Whether to use little endian byte order.\n * @returns The `Uint8Array` corresponding to the `bigint` value.\n */\nexport function numberToUint32(\n  value: number,\n  littleEndian = false,\n): Uint8Array {\n  const bytes = new Uint8Array(4);\n  const view = createDataView(bytes);\n\n  view.setUint32(0, value, littleEndian);\n\n  return bytes;\n}\n\n/**\n * A utility function to check if the Web Crypto API is supported in the current\n * environment.\n *\n * @returns Whether the Web Crypto API is supported.\n */\nexport function isWebCryptoSupported(): boolean {\n  return Boolean(globalThis.crypto?.subtle);\n}\n\n/**\n * Validate the network. If the network is specified, it must be either\n * \"mainnet\" or \"testnet\". This function throws an error if the network is\n * invalid.\n *\n * @param network - The network to validate.\n * @throws An error if the network is invalid.\n */\nexport function validateNetwork(\n  network: unknown,\n): asserts network is Network | undefined {\n  if (network === undefined) {\n    return;\n  }\n\n  if (typeof network !== 'string') {\n    throw new Error('Invalid network: Must be a string if specified.');\n  }\n\n  if (!['mainnet', 'testnet'].includes(network)) {\n    throw new Error(\n      `Invalid network: Must be either \"mainnet\" or \"testnet\" if specified.`,\n    );\n  }\n}\n\n/**\n * Get the BIP-44 coin type from a {@link CoinTypeHDPathTuple} or\n * {@link CoinTypeSeedPathTuple}.\n *\n * This function does not validate the derivation path, and assumes that the\n * derivation path is valid.\n *\n * @param derivationPath - The derivation path to get the BIP-44 coin type from.\n * @returns The BIP-44 coin type.\n */\nexport function getBIP44CoinType(\n  derivationPath: CoinTypeHDPathTuple | CoinTypeSeedPathTuple,\n): number {\n  const pathPart = derivationPath[BIP_44_COIN_TYPE_DEPTH].split(\n    ':',\n  )[1]?.replace(`'`, '');\n\n  assert(pathPart, 'Invalid derivation path: Coin type is not specified.');\n\n  const value = Number.parseInt(pathPart, 10);\n  assert(\n    isValidInteger(value),\n    'Invalid derivation path: Coin type is not a valid integer.',\n  );\n\n  return value;\n}\n"]}