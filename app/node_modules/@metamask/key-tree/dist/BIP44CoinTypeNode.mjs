var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BIP44CoinTypeNode_node;
import { BIP44Node } from "./BIP44Node.mjs";
import { BIP_32_HARDENED_OFFSET } from "./constants.mjs";
import { deriveChildNode } from "./SLIP10Node.mjs";
import { getBIP44CoinType, getBIP32NodeToken, getBIP44ChangePathString, getBIP44CoinTypePathString, getBIP44CoinTypeToAddressPathTuple, getHardenedBIP32NodeToken, getUnhardenedBIP32NodeToken, hexStringToBytes, nullableHexStringToBytes } from "./utils.mjs";
export const BIP_44_COIN_TYPE_DEPTH = 2;
/**
 * A wrapper object for BIP-44 `coin_type` keys. `coin_type` is the index
 * specifying the protocol for which deeper keys are intended. For the
 * authoritative list of coin types, please see
 * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 */
export class BIP44CoinTypeNode {
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param json - The {@link JsonBIP44Node} for the key of this node.
     * @param coin_type - The coin_type index of this node. Must be a non-negative
     * integer.
     * @param cryptographicFunctions - The cryptographic functions to use. If
     * provided, these will be used instead of the built-in implementations.
     * @returns A BIP44CoinType node.
     */
    static async fromJSON(json, coin_type, cryptographicFunctions) {
        validateCoinType(coin_type);
        validateCoinTypeNodeDepth(json.depth);
        const node = await BIP44Node.fromExtendedKey({
            depth: json.depth,
            index: json.index,
            network: json.network,
            parentFingerprint: json.parentFingerprint,
            chainCode: hexStringToBytes(json.chainCode),
            privateKey: nullableHexStringToBytes(json.privateKey),
            publicKey: hexStringToBytes(json.publicKey),
        }, cryptographicFunctions);
        return new BIP44CoinTypeNode(node, coin_type);
    }
    /**
     * Construct a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param derivationPath - The derivation path for the key of this node.
     * @param network - The network for the node. This is only used for extended
     * keys, and defaults to `mainnet`.
     * @param cryptographicFunctions - The cryptographic functions to use. If
     * provided, these will be used instead of the built-in implementations.
     * @returns A BIP44CoinType node.
     */
    static async fromDerivationPath(derivationPath, network, cryptographicFunctions) {
        validateCoinTypeNodeDepth(derivationPath.length - 1);
        const node = await BIP44Node.fromDerivationPath({
            derivationPath,
            network,
        }, cryptographicFunctions);
        const coinType = getBIP44CoinType(derivationPath);
        return new BIP44CoinTypeNode(node, coinType);
    }
    /**
     * Create a new BIP-44 coin type node from a BIP-39 seed. The derivation path
     * must be rooted, i.e. it must begin with a BIP-39 node, given as a
     * `Uint8Array` of the seed bytes.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * @param options - The options for the new node.
     * @param options.derivationPath - The rooted HD tree path that will be used
     * to derive the key of this node.
     * @param options.network - The network for the node. This is only used for
     * extended keys, and defaults to `mainnet`.
     * @param cryptographicFunctions - The cryptographic functions to use. If
     * provided, these will be used instead of the built-in implementations.
     * @returns A new BIP-44 node.
     */
    static async fromSeed({ derivationPath, network }, cryptographicFunctions) {
        validateCoinTypeNodeDepth(derivationPath.length - 1);
        const node = await BIP44Node.fromSeed({
            derivationPath,
            network,
        }, cryptographicFunctions);
        const coinType = getBIP44CoinType(derivationPath);
        return new BIP44CoinTypeNode(node, coinType);
    }
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param node - The {@link BIP44Node} for the key of this node.
     * @param coin_type - The coin_type index of this node. Must be a non-negative
     * integer.
     * @returns A BIP44CoinType node.
     */
    static async fromNode(node, coin_type) {
        if (!(node instanceof BIP44Node)) {
            throw new Error('Invalid node: Expected an instance of BIP44Node.');
        }
        validateCoinType(coin_type);
        validateCoinTypeNodeDepth(node.depth);
        // TODO: Make this function not async in a future version.
        return Promise.resolve(new BIP44CoinTypeNode(node, coin_type));
    }
    // Constructors cannot use hash names.
    // eslint-disable-next-line no-restricted-syntax
    constructor(node, coin_type) {
        _BIP44CoinTypeNode_node.set(this, void 0);
        __classPrivateFieldSet(this, _BIP44CoinTypeNode_node, node, "f");
        this.coin_type = coin_type;
        this.path = getBIP44CoinTypePathString(coin_type);
        Object.freeze(this);
    }
    get depth() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").depth;
    }
    get privateKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").privateKeyBytes;
    }
    get publicKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").publicKeyBytes;
    }
    get chainCodeBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").chainCodeBytes;
    }
    get privateKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").privateKey;
    }
    get publicKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").publicKey;
    }
    get compressedPublicKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").compressedPublicKey;
    }
    get compressedPublicKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").compressedPublicKeyBytes;
    }
    get chainCode() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").chainCode;
    }
    get address() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").address;
    }
    get masterFingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").masterFingerprint;
    }
    get parentFingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").parentFingerprint;
    }
    get fingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").fingerprint;
    }
    get index() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").index;
    }
    get network() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").network;
    }
    get curve() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").curve;
    }
    get extendedKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").extendedKey;
    }
    /**
     * Derives a BIP-44 `address_index` key corresponding to the path of this
     * node and the specified `account`, `change`, and `address_index` values.
     * `address_index` keys are normally the keys used to generate user account
     * addresses.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param indices - The BIP-44 index values to use in key derivation.
     * @param indices.account - The `account` index. Default: `0`
     * @param indices.change - The `change` index. Default: `0`
     * @param indices.address_index - The `address_index` index.
     * @returns The derived BIP-44 `address_index` node.
     */
    async deriveBIP44AddressKey({ account = 0, change = 0, address_index, }) {
        return await __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").derive(getBIP44CoinTypeToAddressPathTuple({ account, change, address_index }));
    }
    toJSON() {
        return {
            ...__classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").toJSON(),
            coin_type: this.coin_type,
            path: this.path,
        };
    }
}
_BIP44CoinTypeNode_node = new WeakMap();
/**
 * Validates the depth of a `coin_type` node. Simply, ensures that it is the
 * number `2`. An error is thrown if validation fails.
 *
 * @param depth - The depth to validate.
 */
function validateCoinTypeNodeDepth(depth) {
    if (depth !== BIP_44_COIN_TYPE_DEPTH) {
        throw new Error(`Invalid depth: Coin type nodes must be of depth ${BIP_44_COIN_TYPE_DEPTH}. Received: "${depth}"`);
    }
}
/**
 * Validates that the coin type is a non-negative integer number. An error is
 * thrown if validation fails.
 *
 * @param coin_type - The coin type to validate.
 */
function validateCoinType(coin_type) {
    if (typeof coin_type !== 'number' ||
        !Number.isInteger(coin_type) ||
        coin_type < 0) {
        throw new Error('Invalid coin type: The specified coin type must be a non-negative integer number.');
    }
}
/**
 * Derives a BIP-44 address key corresponding to the specified derivation path,
 * given either by a {@link BIP44CoinTypeNode} or derivation path tuple.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param parentKeyOrNode - The `coin_type` parent key to derive from.
 * @param indices - The BIP-44 index values to use in key derivation.
 * @param indices.account - The `account` index. Default: `0`.
 * @param indices.change - The `change` index. Default: `0`.
 * @param indices.address_index - The `address_index` index.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The derived `address_index` key for the specified derivation path.
 */
export async function deriveBIP44AddressKey(parentKeyOrNode, { account = 0, change = 0, address_index }, cryptographicFunctions) {
    const path = getBIP44CoinTypeToAddressPathTuple({
        account,
        change,
        address_index,
    });
    const node = await getNode(parentKeyOrNode, cryptographicFunctions);
    const childNode = await deriveChildNode({
        path,
        node,
    }, cryptographicFunctions);
    return new BIP44Node(childNode);
}
/**
 * Creates a function that derives BIP-44 address keys corresponding to the
 * specified derivation path, given either by a {@link BIP44CoinTypeNode} or
 * derivation path tuple.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param node - The {@link BIP44CoinTypeNode} to derive address keys from.
 * This node contains a BIP-44 key of depth 2, `coin_type`.
 * @param accountAndChangeIndices - The `account` and `change` indices that
 * will be used to derive addresses.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The deriver function for the derivation path specified by the
 * `coin_type` node, `account`, and `change` indices.
 */
export async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices, cryptographicFunctions) {
    const { account = 0, change = 0 } = accountAndChangeIndices ?? {};
    const actualNode = await getNode(node, cryptographicFunctions);
    const accountNode = getHardenedBIP32NodeToken(account);
    const changeNode = getBIP32NodeToken(change);
    const bip44AddressKeyDeriver = async (address_index, isHardened = false) => {
        const slip10Node = await deriveChildNode({
            path: [
                accountNode,
                changeNode,
                isHardened
                    ? getHardenedBIP32NodeToken(address_index)
                    : getUnhardenedBIP32NodeToken(address_index),
            ],
            node: actualNode,
        }, cryptographicFunctions);
        return new BIP44Node(slip10Node);
    };
    bip44AddressKeyDeriver.coin_type = actualNode.coin_type;
    bip44AddressKeyDeriver.path = getBIP44ChangePathString(actualNode.path, {
        account,
        change,
    });
    Object.freeze(bip44AddressKeyDeriver);
    return bip44AddressKeyDeriver;
}
/**
 * Get a BIP-44 coin type node from a JSON node or extended key string. If an existing coin type
 * node is provided, the same node is returned.
 *
 * The depth of the node is validated to be a valid coin type node.
 *
 * @param node - A BIP-44 coin type node, JSON node or extended key.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations. This is
 * only used if the node is an extended key string or JSON object.
 * @returns A BIP44CoinType node.
 */
async function getNode(node, cryptographicFunctions) {
    if (node instanceof BIP44CoinTypeNode) {
        validateCoinTypeNodeDepth(node.depth);
        return node;
    }
    if (typeof node === 'string') {
        const bip44Node = await BIP44Node.fromExtendedKey(node, cryptographicFunctions);
        const coinTypeNode = await BIP44CoinTypeNode.fromNode(bip44Node, bip44Node.index - BIP_32_HARDENED_OFFSET);
        validateCoinTypeNodeDepth(coinTypeNode.depth);
        return coinTypeNode;
    }
    return BIP44CoinTypeNode.fromJSON(node, node.coin_type, cryptographicFunctions);
}
//# sourceMappingURL=BIP44CoinTypeNode.mjs.map