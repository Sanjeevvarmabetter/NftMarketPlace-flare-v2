import type { DeriveChildKeyArgs } from "./index.cjs";
import type { Network } from "../constants.cjs";
import type { CryptographicFunctions } from "../cryptography.cjs";
import type { Curve } from "../curves/index.cjs";
import { SLIP10Node } from "../SLIP10Node.cjs";
type ErrorHandler = (error: unknown, options: DeriveNodeArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<DeriveNodeArgs>;
/**
 * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.
 *
 * Since BIP-32 and SLIP-10 are very similar, this function can be used to
 * derive both types of keys.
 *
 * @param options - The options for deriving a child key.
 * @param options.path - The derivation path part to derive.
 * @param options.node - The node to derive from.
 * @param options.curve - The curve to use for derivation.
 * @param options.network - The network for the node. This is only used for
 * extended keys, and defaults to `mainnet`.
 * @param handleError - A function that can handle errors that occur during
 * derivation.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The derived node.
 */
export declare function deriveChildKey({ path, node, curve, network }: DeriveChildKeyArgs, handleError: ErrorHandler, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
type BaseDeriveNodeArgs = {
    entropy: Uint8Array;
    chainCode: Uint8Array;
    childIndex: number;
    isHardened: boolean;
    depth: number;
    parentFingerprint: number;
    masterFingerprint?: number | undefined;
    curve: Curve;
    network?: Network | undefined;
};
type DerivePrivateKeyArgs = BaseDeriveNodeArgs & {
    privateKey: Uint8Array;
    publicKey: Uint8Array;
};
type DerivePublicKeyArgs = BaseDeriveNodeArgs & {
    publicKey: Uint8Array;
    privateKey?: never | undefined;
};
export type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;
type DeriveSecretExtensionArgs = {
    privateKey: Uint8Array;
    publicKey: Uint8Array;
    childIndex: number;
    isHardened: boolean;
    curve: Curve;
};
/**
 * Derive a BIP-32 secret extension from a parent key and child index.
 *
 * @param options - The options for deriving a secret extension.
 * @param options.privateKey - The parent private key bytes.
 * @param options.publicKey - The parent compressed public key bytes.
 * @param options.childIndex - The child index to derive.
 * @param options.isHardened - Whether the child index is hardened.
 * @param options.curve - The curve to use for derivation.
 * @returns The secret extension bytes.
 */
export declare function deriveSecretExtension({ privateKey, publicKey, childIndex, isHardened, curve, }: DeriveSecretExtensionArgs): Promise<Uint8Array>;
type DerivePublicExtensionArgs = {
    parentPublicKey: Uint8Array;
    childIndex: number;
};
/**
 * Derive a BIP-32 public extension from a parent key and child index.
 *
 * @param options - The options for deriving a public extension.
 * @param options.parentPublicKey - The parent public key bytes.
 * @param options.childIndex - The child index to derive.
 * @returns The public extension bytes.
 */
export declare function derivePublicExtension({ parentPublicKey, childIndex, }: DerivePublicExtensionArgs): Uint8Array;
type DerivePublicChildKeyArgs = {
    entropy: Uint8Array;
    publicKey: Uint8Array;
    depth: number;
    masterFingerprint?: number | undefined;
    parentFingerprint: number;
    childIndex: number;
    curve: Curve;
    network?: Network | undefined;
};
/**
 * Derive a BIP-32 public child key with a given path from a parent key.
 *
 * @param args - The arguments for deriving a public child key.
 * @param args.entropy - The entropy to use for derivation.
 * @param args.publicKey - The parent public key to use for derivation.
 * @param args.depth - The depth of the parent node.
 * @param args.masterFingerprint - The fingerprint of the master node.
 * @param args.parentFingerprint - The fingerprint of the parent node.
 * @param args.childIndex - The child index to derive.
 * @param args.curve - The curve to use for derivation.
 * @param args.network - The network for the node. This is only used for
 * extended keys, and defaults to `mainnet`.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The derived {@link SLIP10Node}.
 */
export declare function derivePublicChildKey({ entropy, publicKey, depth, masterFingerprint, parentFingerprint, childIndex, curve, network, }: DerivePublicChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
/**
 * Add a tweak to the private key: `(privateKey + tweak) % n`.
 *
 * @param privateKeyBytes - The private key as 32 byte Uint8Array.
 * @param tweakBytes - The tweak as 32 byte Uint8Array.
 * @param curve - The curve to use.
 * @throws If the private key or tweak is invalid.
 * @returns The private key with the tweak added to it.
 */
export declare function privateAdd(privateKeyBytes: Uint8Array, tweakBytes: Uint8Array, curve: Curve): Uint8Array;
type GenerateEntropyArgs = {
    chainCode: Uint8Array;
    extension: Uint8Array;
};
/**
 * Generate 64 bytes of (deterministic) entropy from a chain code and secret
 * extension.
 *
 * @param args - The arguments for generating entropy.
 * @param args.chainCode - The parent chain code bytes.
 * @param args.extension - The extension bytes.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The generated entropy bytes.
 */
export declare function generateEntropy({ chainCode, extension }: GenerateEntropyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
/**
 * Validate that a node is specified.
 *
 * @param node - The node to validate.
 * @throws If the node is not specified.
 */
export declare function validateNode(node?: SLIP10Node): asserts node is SLIP10Node;
/**
 * Validate a path and return the child index and whether it is hardened.
 *
 * @param path - The path to validate.
 * @param node - The node to validate the path against.
 * @param curve - The curve to validate the path against.
 * @returns The child index and whether it is hardened.
 */
export declare function getValidatedPath(path: string | Uint8Array, node: SLIP10Node, curve: Curve): {
    childIndex: number;
    isHardened: boolean;
};
export {};
//# sourceMappingURL=shared.d.cts.map