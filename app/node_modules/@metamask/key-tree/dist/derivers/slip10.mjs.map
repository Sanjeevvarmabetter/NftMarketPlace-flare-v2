{"version":3,"file":"slip10.mjs","sourceRoot":"","sources":["../../src/derivers/slip10.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,wBAAwB;AAG9C,OAAO,EACL,eAAe,EACf,cAAc,IAAI,oBAAoB,EACvC,qBAAiB;AAElB,OAAO,EAAE,sBAAsB,EAAE,yBAAqB;AAGtD,OAAO,EAAE,cAAc,EAAE,qBAAiB;AAE1C;;;;;;;;GAQG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,OAA2B,EAC3B,sBAA+C;IAE/C,OAAO,MAAM,oBAAoB,CAC/B,OAAO,EACP,WAAW,EACX,sBAAsB,CACvB,CAAC;AACJ,CAAC;AAED;;;;;;;;GAQG;AACH,KAAK,UAAU,WAAW,CACxB,KAAc,EACd,OAAuB,EACvB,sBAA+C;IAE/C,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG,OAAO,CAAC;IAEtE,4EAA4E;IAC5E,yBAAyB;IACzB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;QAC7B,MAAM,KAAK,CAAC;IACd,CAAC;IAED,MAAM,gBAAgB,GAAG,UAAU;QACjC,CAAC,CAAC,UAAU,GAAG,sBAAsB;QACrC,CAAC,CAAC,UAAU,CAAC;IAEf,sEAAsE;IACtE,wBAAwB;IACxB,yDAAyD;IACzD,kFAAkF;IAClF,MAAM,UAAU,GAAG,MAAM,eAAe,CACtC;QACE,SAAS;QACT,SAAS,EAAE,WAAW,CAAC;YACrB,IAAI;YACJ,OAAO,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;YACrB,cAAc,CAAC,gBAAgB,CAAC;SACjC,CAAC;KACH,EACD,sBAAsB,CACvB,CAAC;IAEF,OAAO;QACL,GAAG,OAAO;QACV,OAAO,EAAE,UAAU;KACpB,CAAC;AACJ,CAAC","sourcesContent":["import { concatBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport {\n  generateEntropy,\n  deriveChildKey as sharedDeriveChildKey,\n} from './shared';\nimport type { DeriveNodeArgs } from './shared';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns A tuple containing the derived private key, public key and chain\n * code.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  return await sharedDeriveChildKey(\n    options,\n    handleError,\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Handle an error that occurs during SLIP-10 derivation.\n *\n * @param error - The error that occurred.\n * @param options - The options that were used for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The new options to use for derivation.\n */\nasync function handleError(\n  error: unknown,\n  options: DeriveNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<DeriveNodeArgs> {\n  const { curve, isHardened, childIndex, entropy, chainCode } = options;\n\n  // `ed25519` keys are always valid, so this error should never be thrown. If\n  // it is, we re-throw it.\n  if (curve.name === 'ed25519') {\n    throw error;\n  }\n\n  const actualChildIndex = isHardened\n    ? childIndex + BIP_32_HARDENED_OFFSET\n    : childIndex;\n\n  // As per SLIP-10, if the resulting key is invalid, the new entropy is\n  // generated as follows:\n  // Key material (32 bytes), child chain code (32 bytes) =\n  //   HMAC-SHA512(parent chain code, 0x01 || chain code from invalid key || index).\n  const newEntropy = await generateEntropy(\n    {\n      chainCode,\n      extension: concatBytes([\n        0x01,\n        entropy.slice(32, 64),\n        numberToUint32(actualChildIndex),\n      ]),\n    },\n    cryptographicFunctions,\n  );\n\n  return {\n    ...options,\n    entropy: newEntropy,\n  };\n}\n"]}