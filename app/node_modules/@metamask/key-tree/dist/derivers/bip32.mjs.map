{"version":3,"file":"bip32.mjs","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,wBAAwB;AAIzC,OAAO,EACL,cAAc,IAAI,oBAAoB,EACtC,qBAAqB,EACrB,eAAe,EACf,qBAAqB,EACtB,qBAAiB;AAClB,OAAO,EAAE,gBAAgB,EAAE,yBAAqB;AAEhD,OAAO,EAAE,SAAS,EAAE,4BAAwB;AAC5C,OAAO,EAAE,SAAS,EAAE,4BAAkB;AAEtC,OAAO,EAAE,eAAe,EAAE,kBAAkB,EAAE,qBAAiB;AAE/D;;;;;;;;;;GAUG;AACH,MAAM,UAAU,sBAAsB,CAAC,GAAe;IACpD,MAAM,CACJ,GAAG,YAAY,UAAU,IAAI,eAAe,CAAC,GAAG,EAAE,gBAAgB,CAAC,EACnE,8DAA8D,CAC/D,CAAC;IAEF,MAAM,SAAS,GAAG,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IACrD,OAAO,qBAAqB,CAAC,SAAS,CAAC,CAAC;AAC1C,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,qBAAqB,CAAC,GAAe;IACnD,MAAM,CACJ,GAAG,YAAY,UAAU;QACvB,eAAe,CAAC,GAAG,EAAE,SAAS,CAAC,eAAe,CAAC,EACjD,8DAA8D,CAC/D,CAAC;IAEF,OAAO,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;AAC5C,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,OAA2B,EAC3B,sBAA+C;IAE/C,MAAM,CACJ,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,WAAW,EAClC,uDAAuD,CACxD,CAAC;IAEF,OAAO,oBAAoB,CAAC,OAAO,EAAE,WAAW,EAAE,sBAAsB,CAAC,CAAC;AAC5E,CAAC;AAED;;;;;;;;;;GAUG;AACH,KAAK,UAAU,WAAW,CACxB,CAAU,EACV,OAAuB,EACvB,sBAA+C;IAE/C,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,KAAK,EAAE,GACvE,OAAO,CAAC;IAEV,kBAAkB,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;IAEnC,IAAI,UAAU,EAAE,CAAC;QACf,MAAM,eAAe,GAAG,MAAM,qBAAqB,CAAC;YAClD,UAAU;YACV,SAAS,EAAE,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC;YAC7C,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,UAAU;YACV,KAAK;SACN,CAAC,CAAC;QAEH,MAAM,UAAU,GAAG,MAAM,eAAe,CACtC;YACE,SAAS;YACT,SAAS,EAAE,eAAe;SAC3B,EACD,sBAAsB,CACvB,CAAC;QAEF,OAAO;YACL,GAAG,OAAO;YACV,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,OAAO,EAAE,UAAU;SACpB,CAAC;IACJ,CAAC;IAED,MAAM,eAAe,GAAG,qBAAqB,CAAC;QAC5C,eAAe,EAAE,SAAS;QAC1B,UAAU,EAAE,UAAU,GAAG,CAAC;KAC3B,CAAC,CAAC;IAEH,MAAM,UAAU,GAAG,MAAM,eAAe,CAAC;QACvC,SAAS;QACT,SAAS,EAAE,eAAe;KAC3B,CAAC,CAAC;IAEH,OAAO;QACL,GAAG,OAAO;QACV,UAAU,EAAE,UAAU,GAAG,CAAC;QAC1B,OAAO,EAAE,UAAU;KACpB,CAAC;AACJ,CAAC","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport type { DeriveNodeArgs } from './shared';\nimport {\n  deriveChildKey as sharedDeriveChildKey,\n  deriveSecretExtension,\n  generateEntropy,\n  derivePublicExtension,\n} from './shared';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { keccak256 } from '../cryptography';\nimport { secp256k1 } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, validateBIP32Index } from '../utils';\n\n/**\n * Converts a BIP-32 private key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` private key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function privateKeyToEthAddress(key: Uint8Array): Uint8Array {\n  assert(\n    key instanceof Uint8Array && isValidBytesKey(key, BYTES_KEY_LENGTH),\n    'Invalid key: The key must be a 32-byte, non-zero Uint8Array.',\n  );\n\n  const publicKey = secp256k1.getPublicKey(key, false);\n  return publicKeyToEthAddress(publicKey);\n}\n\n/**\n * Converts a BIP-32 public key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` public key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function publicKeyToEthAddress(key: Uint8Array): Uint8Array {\n  assert(\n    key instanceof Uint8Array &&\n      isValidBytesKey(key, secp256k1.publicKeyLength),\n    'Invalid key: The key must be a 65-byte, non-zero Uint8Array.',\n  );\n\n  return keccak256(key.slice(1)).slice(-20);\n}\n\n/**\n * Derive a BIP-32 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child key as a {@link SLIP10Node}.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    options.curve.name === 'secp256k1',\n    'Invalid curve: Only secp256k1 is supported by BIP-32.',\n  );\n\n  return sharedDeriveChildKey(options, handleError, cryptographicFunctions);\n}\n\n/**\n * Handles an error thrown during derivation by incrementing the child index\n * and retrying.\n *\n * @param _ - The error that was thrown.\n * @param options - The options for deriving a child key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The options for deriving a child key with the child index\n * incremented by one.\n */\nasync function handleError(\n  _: unknown,\n  options: DeriveNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<DeriveNodeArgs> {\n  const { childIndex, privateKey, publicKey, isHardened, chainCode, curve } =\n    options;\n\n  validateBIP32Index(childIndex + 1);\n\n  if (privateKey) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey,\n      publicKey: curve.compressPublicKey(publicKey),\n      childIndex: childIndex + 1,\n      isHardened,\n      curve,\n    });\n\n    const newEntropy = await generateEntropy(\n      {\n        chainCode,\n        extension: secretExtension,\n      },\n      cryptographicFunctions,\n    );\n\n    return {\n      ...options,\n      childIndex: childIndex + 1,\n      entropy: newEntropy,\n    };\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: publicKey,\n    childIndex: childIndex + 1,\n  });\n\n  const newEntropy = await generateEntropy({\n    chainCode,\n    extension: publicExtension,\n  });\n\n  return {\n    ...options,\n    childIndex: childIndex + 1,\n    entropy: newEntropy,\n  };\n}\n"]}