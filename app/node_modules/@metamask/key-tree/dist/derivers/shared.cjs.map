{"version":3,"file":"shared.cjs","sourceRoot":"","sources":["../../src/derivers/shared.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  assert,\n  bytesToBigInt,\n  concatBytes,\n  hexToBytes,\n} from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs, DerivedKeys } from '.';\nimport type { Network } from '../constants';\nimport { BIP_32_HARDENED_OFFSET, UNPREFIXED_PATH_REGEX } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { hmacSha512 } from '../cryptography';\nimport type { Curve } from '../curves';\nimport { mod } from '../curves';\nimport { PUBLIC_KEY_GUARD } from '../guard';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, numberToUint32, validateBytes } from '../utils';\n\ntype ErrorHandler = (\n  error: unknown,\n  options: DeriveNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n) => Promise<DeriveNodeArgs>;\n\n/**\n * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.\n *\n * Since BIP-32 and SLIP-10 are very similar, this function can be used to\n * derive both types of keys.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param options.network - The network for the node. This is only used for\n * extended keys, and defaults to `mainnet`.\n * @param handleError - A function that can handle errors that occur during\n * derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived node.\n */\nexport async function deriveChildKey(\n  { path, node, curve, network }: DeriveChildKeyArgs,\n  handleError: ErrorHandler,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n\n  const args = {\n    chainCode: node.chainCodeBytes,\n    childIndex,\n    isHardened,\n    depth: node.depth,\n    parentFingerprint: node.fingerprint,\n    masterFingerprint: node.masterFingerprint,\n    curve,\n    network,\n  };\n\n  if (node.privateKeyBytes) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey: node.privateKeyBytes,\n      get publicKey() {\n        return node.compressedPublicKeyBytes;\n      },\n      childIndex,\n      isHardened,\n      curve,\n    });\n\n    const entropy = await generateEntropy(\n      {\n        chainCode: node.chainCodeBytes,\n        extension: secretExtension,\n      },\n      cryptographicFunctions,\n    );\n\n    return await deriveNode(\n      {\n        privateKey: node.privateKeyBytes,\n        get publicKey() {\n          return node.publicKeyBytes;\n        },\n        entropy,\n        ...args,\n      },\n      handleError,\n      cryptographicFunctions,\n    );\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: node.compressedPublicKeyBytes,\n    childIndex,\n  });\n\n  const entropy = await generateEntropy(\n    {\n      chainCode: node.chainCodeBytes,\n      extension: publicExtension,\n    },\n    cryptographicFunctions,\n  );\n\n  return await deriveNode(\n    {\n      publicKey: node.compressedPublicKeyBytes,\n      entropy,\n      ...args,\n    },\n    handleError,\n    cryptographicFunctions,\n  );\n}\n\ntype BaseDeriveNodeArgs = {\n  entropy: Uint8Array;\n  chainCode: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  depth: number;\n  parentFingerprint: number;\n  masterFingerprint?: number | undefined;\n  curve: Curve;\n  network?: Network | undefined;\n};\n\ntype DerivePrivateKeyArgs = BaseDeriveNodeArgs & {\n  privateKey: Uint8Array;\n  publicKey: Uint8Array;\n};\n\ntype DerivePublicKeyArgs = BaseDeriveNodeArgs & {\n  publicKey: Uint8Array;\n  privateKey?: never | undefined;\n};\n\nexport type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;\n\ntype DeriveSecretExtensionArgs = {\n  privateKey: Uint8Array;\n  publicKey: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a SLIP-10 child key from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.privateKey - The private key to derive from.\n * @param options.publicKey - The public key to derive from.\n * @param options.entropy - The entropy to use for deriving the child key.\n * @param options.chainCode - The chain code to use for deriving the child key.\n * @param options.childIndex - The child index to use for deriving the child key.\n * @param options.isHardened - Whether the child key is hardened.\n * @param options.depth - The depth of the child key.\n * @param options.parentFingerprint - The fingerprint of the parent key.\n * @param options.masterFingerprint - The fingerprint of the master key.\n * @param options.curve - The curve to use for deriving the child key.\n * @param handleError - A function to handle errors during derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child key as {@link SLIP10Node}.\n */\nasync function deriveNode(\n  options: DeriveNodeArgs,\n  handleError: ErrorHandler,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const {\n    privateKey,\n    publicKey,\n    entropy,\n    childIndex,\n    isHardened,\n    depth,\n    parentFingerprint,\n    masterFingerprint,\n    curve,\n    network,\n  } = options;\n\n  try {\n    if (privateKey) {\n      return await derivePrivateChildKey(\n        {\n          entropy,\n          privateKey,\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          childIndex,\n          isHardened,\n          curve,\n          network,\n        },\n        cryptographicFunctions,\n      );\n    }\n\n    return await derivePublicChildKey(\n      {\n        entropy,\n        publicKey,\n        depth,\n        masterFingerprint,\n        parentFingerprint,\n        childIndex,\n        curve,\n        network,\n      },\n      cryptographicFunctions,\n    );\n  } catch (error) {\n    return await deriveNode(\n      await handleError(error, options, cryptographicFunctions),\n      handleError,\n      cryptographicFunctions,\n    );\n  }\n}\n\n/**\n * Derive a BIP-32 secret extension from a parent key and child index.\n *\n * @param options - The options for deriving a secret extension.\n * @param options.privateKey - The parent private key bytes.\n * @param options.publicKey - The parent compressed public key bytes.\n * @param options.childIndex - The child index to derive.\n * @param options.isHardened - Whether the child index is hardened.\n * @param options.curve - The curve to use for derivation.\n * @returns The secret extension bytes.\n */\nexport async function deriveSecretExtension({\n  privateKey,\n  publicKey,\n  childIndex,\n  isHardened,\n  curve,\n}: DeriveSecretExtensionArgs): Promise<Uint8Array> {\n  if (isHardened) {\n    // Hardened child\n    return concatBytes([\n      new Uint8Array([0]),\n      privateKey,\n      numberToUint32(childIndex + BIP_32_HARDENED_OFFSET),\n    ]);\n  }\n\n  // Normal child\n  validateBytes(publicKey, curve.compressedPublicKeyLength);\n  return derivePublicExtension({ parentPublicKey: publicKey, childIndex });\n}\n\ntype DerivePublicExtensionArgs = {\n  parentPublicKey: Uint8Array;\n  childIndex: number;\n};\n\n/**\n * Derive a BIP-32 public extension from a parent key and child index.\n *\n * @param options - The options for deriving a public extension.\n * @param options.parentPublicKey - The parent public key bytes.\n * @param options.childIndex - The child index to derive.\n * @returns The public extension bytes.\n */\nexport function derivePublicExtension({\n  parentPublicKey,\n  childIndex,\n}: DerivePublicExtensionArgs): Uint8Array {\n  return concatBytes([parentPublicKey, numberToUint32(childIndex)]);\n}\n\ntype GenerateKeyArgs = {\n  privateKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 key from a parent key and secret extension.\n *\n * @param options - The options for deriving a key.\n * @param options.privateKey - The parent private key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived key.\n */\nfunction generateKey({ privateKey, entropy, curve }: GenerateKeyArgs): Omit<\n  DerivedKeys,\n  'publicKey'\n> & {\n  privateKey: Uint8Array;\n} {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // If curve is ed25519: The returned child key ki is parse256(IL).\n  // https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#private-parent-key--private-child-key\n  if (curve.name === 'ed25519') {\n    return { privateKey: keyMaterial, chainCode: childChainCode };\n  }\n\n  const childPrivateKey = privateAdd(privateKey, keyMaterial, curve);\n\n  return { privateKey: childPrivateKey, chainCode: childChainCode };\n}\n\ntype DerivePrivateChildKeyArgs = {\n  entropy: Uint8Array;\n  privateKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n  network?: Network | undefined;\n};\n\n/**\n * Derive a BIP-32 private child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a private child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.privateKey - The parent private key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.isHardened - Whether the child index is hardened.\n * @param args.curve - The curve to use for derivation.\n * @param args.network - The network for the node. This is only used for\n * extended keys, and defaults to `mainnet`.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived {@link SLIP10Node}.\n */\nasync function derivePrivateChildKey(\n  {\n    entropy,\n    privateKey,\n    depth,\n    masterFingerprint,\n    parentFingerprint,\n    childIndex,\n    isHardened,\n    curve,\n    network,\n  }: DerivePrivateChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const { privateKey: childPrivateKey, chainCode: childChainCode } =\n    generateKey({\n      privateKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey(\n    {\n      privateKey: childPrivateKey,\n      chainCode: childChainCode,\n      depth: depth + 1,\n      masterFingerprint,\n      parentFingerprint,\n      index: actualChildIndex,\n      curve: curve.name,\n      network,\n      guard: PUBLIC_KEY_GUARD,\n    },\n    cryptographicFunctions,\n  );\n}\n\ntype GeneratePublicKeyArgs = {\n  publicKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public key from a parent key and public extension.\n *\n * @param options - The options for deriving a public key.\n * @param options.publicKey - The parent public key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived public key.\n */\nfunction generatePublicKey({\n  publicKey,\n  entropy,\n  curve,\n}: GeneratePublicKeyArgs): DerivedKeys {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // This function may fail if the resulting key is invalid.\n  const childPublicKey = curve.publicAdd(publicKey, keyMaterial);\n\n  return {\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n  };\n}\n\ntype DerivePublicChildKeyArgs = {\n  entropy: Uint8Array;\n  publicKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  curve: Curve;\n  network?: Network | undefined;\n};\n\n/**\n * Derive a BIP-32 public child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a public child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.publicKey - The parent public key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.curve - The curve to use for derivation.\n * @param args.network - The network for the node. This is only used for\n * extended keys, and defaults to `mainnet`.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived {@link SLIP10Node}.\n */\nexport async function derivePublicChildKey(\n  {\n    entropy,\n    publicKey,\n    depth,\n    masterFingerprint,\n    parentFingerprint,\n    childIndex,\n    curve,\n    network,\n  }: DerivePublicChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const { publicKey: childPublicKey, chainCode: childChainCode } =\n    generatePublicKey({\n      publicKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey(\n    {\n      publicKey: childPublicKey,\n      chainCode: childChainCode,\n      depth: depth + 1,\n      masterFingerprint,\n      parentFingerprint,\n      index: childIndex,\n      curve: curve.name,\n      network,\n    },\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Add a tweak to the private key: `(privateKey + tweak) % n`.\n *\n * @param privateKeyBytes - The private key as 32 byte Uint8Array.\n * @param tweakBytes - The tweak as 32 byte Uint8Array.\n * @param curve - The curve to use.\n * @throws If the private key or tweak is invalid.\n * @returns The private key with the tweak added to it.\n */\nexport function privateAdd(\n  privateKeyBytes: Uint8Array,\n  tweakBytes: Uint8Array,\n  curve: Curve,\n): Uint8Array {\n  assert(\n    isValidBytesKey(tweakBytes, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const privateKey = bytesToBigInt(privateKeyBytes);\n  const tweak = bytesToBigInt(tweakBytes);\n\n  if (tweak >= curve.curve.n) {\n    throw new Error('Invalid tweak: Tweak is larger than the curve order.');\n  }\n\n  const added = mod(privateKey + tweak, curve.curve.n);\n  const bytes = hexToBytes(added.toString(16).padStart(64, '0'));\n\n  if (!curve.isValidPrivateKey(bytes)) {\n    throw new Error(\n      'Invalid private key or tweak: The resulting private key is invalid.',\n    );\n  }\n\n  return bytes;\n}\n\ntype GenerateEntropyArgs = {\n  chainCode: Uint8Array;\n  extension: Uint8Array;\n};\n\n/**\n * Generate 64 bytes of (deterministic) entropy from a chain code and secret\n * extension.\n *\n * @param args - The arguments for generating entropy.\n * @param args.chainCode - The parent chain code bytes.\n * @param args.extension - The extension bytes.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The generated entropy bytes.\n */\nexport async function generateEntropy(\n  { chainCode, extension }: GenerateEntropyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> {\n  return await hmacSha512(chainCode, extension, cryptographicFunctions);\n}\n\n/**\n * Validate that a node is specified.\n *\n * @param node - The node to validate.\n * @throws If the node is not specified.\n */\nexport function validateNode(node?: SLIP10Node): asserts node is SLIP10Node {\n  assert(node, 'Invalid parameters: Must specify a node to derive from.');\n}\n\n/**\n * Validate a path.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @throws If the path is invalid.\n */\nfunction validatePath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): asserts path is string {\n  assert(typeof path === 'string', 'Invalid path: Must be a string.');\n\n  const isHardened = path.endsWith(`'`);\n  assert(\n    !isHardened || node.privateKey,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n  assert(\n    isHardened || curve.deriveUnhardenedKeys,\n    `Invalid path: Cannot derive unhardened child keys with ${curve.name}.`,\n  );\n}\n\n/**\n * Validate a path and return the child index and whether it is hardened.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @returns The child index and whether it is hardened.\n */\nexport function getValidatedPath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): { childIndex: number; isHardened: boolean } {\n  validatePath(path, node, curve);\n\n  const indexPart = path.split(`'`)[0];\n\n  assert(indexPart);\n  const childIndex = parseInt(indexPart, 10);\n\n  if (\n    !UNPREFIXED_PATH_REGEX.test(indexPart) ||\n    !Number.isInteger(childIndex) ||\n    childIndex < 0 ||\n    childIndex >= BIP_32_HARDENED_OFFSET\n  ) {\n    throw new Error(\n      `Invalid path: The index must be a non-negative decimal integer less than ${BIP_32_HARDENED_OFFSET}.`,\n    );\n  }\n\n  return { childIndex, isHardened: path.includes(`'`) };\n}\n"]}