"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.entropyToCip3MasterNode = exports.createBip39KeyFromSeed = exports.deriveChildKey = exports.getDerivationPathWithSeed = exports.multipathToBip39Mnemonic = exports.bip39MnemonicToMultipath = exports.mnemonicToSeed = void 0;
const scure_bip39_1 = require("@metamask/scure-bip39");
const english_1 = require("@metamask/scure-bip39/dist/wordlists/english.js");
const utils_1 = require("@metamask/utils");
const constants_1 = require("../constants.cjs");
const cryptography_1 = require("../cryptography.cjs");
const curves_1 = require("../curves/index.cjs");
const guard_1 = require("../guard.cjs");
const SLIP10Node_1 = require("../SLIP10Node.cjs");
const utils_2 = require("../utils.cjs");
const MNEMONIC_PHRASE_LENGTHS = [12, 15, 18, 21, 24];
/**
 * Validate a BIP-39 mnemonic phrase. The phrase must:
 *
 * - Consist of 12, 15, 18, 21, or 24 words.
 * - Contain only words from the English wordlist.
 *
 * @param mnemonicPhrase - The mnemonic phrase to validate.
 * @throws If the mnemonic phrase is invalid.
 */
function validateMnemonicPhrase(mnemonicPhrase) {
    const words = mnemonicPhrase.split(' ');
    (0, utils_1.assert)(MNEMONIC_PHRASE_LENGTHS.includes(words.length), `Invalid mnemonic phrase: The mnemonic phrase must consist of 12, 15, 18, 21, or 24 words.`);
    (0, utils_1.assert)(words.every((word) => english_1.wordlist.includes(word)), 'Invalid mnemonic phrase: The mnemonic phrase contains an unknown word.');
}
/**
 * Encode a BIP-39 mnemonic phrase to a `Uint8Array` for use in seed generation.
 * If the mnemonic is already a `Uint8Array`, it is assumed to contain the
 * indices of the words in the wordlist.
 *
 * @param mnemonic - The mnemonic phrase to encode.
 * @param wordlist - The wordlist to use.
 * @returns The encoded mnemonic phrase.
 */
function encodeMnemonicPhrase(mnemonic, wordlist) {
    if (typeof mnemonic === 'string') {
        validateMnemonicPhrase(mnemonic);
        return (0, utils_1.stringToBytes)(mnemonic.normalize('NFKD'));
    }
    const mnemonicString = Array.from(new Uint16Array(mnemonic.buffer))
        .map((i) => wordlist[i])
        .join(' ');
    validateMnemonicPhrase(mnemonicString);
    return (0, utils_1.stringToBytes)(mnemonicString);
}
/**
 * Convert a BIP-39 mnemonic phrase to a seed.
 *
 * @param mnemonic - The BIP-39 mnemonic phrase to convert. If the mnemonic is a
 * `Uint8Array`, it is assumed to contain the indices of the words in the
 * English wordlist.
 * @param passphrase - The passphrase to use.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The seed.
 */
async function mnemonicToSeed(mnemonic, passphrase = '', cryptographicFunctions) {
    const salt = `mnemonic${passphrase}`.normalize('NFKD');
    return await (0, cryptography_1.pbkdf2Sha512)(encodeMnemonicPhrase(mnemonic, english_1.wordlist), (0, utils_1.stringToBytes)(salt), 2048, 64, cryptographicFunctions);
}
exports.mnemonicToSeed = mnemonicToSeed;
/**
 * Convert a BIP-39 mnemonic phrase to a multi path.
 *
 * @param mnemonic - The BIP-39 mnemonic phrase to convert.
 * @returns The multi path.
 */
function bip39MnemonicToMultipath(mnemonic) {
    return `bip39:${mnemonic.toLowerCase().trim()}`;
}
exports.bip39MnemonicToMultipath = bip39MnemonicToMultipath;
/**
 * Convert a multi path to a BIP-39 mnemonic phrase.
 *
 * @param value - The multi path to convert.
 * @returns The BIP-39 mnemonic phrase.
 */
function multipathToBip39Mnemonic(value) {
    if (value instanceof Uint8Array) {
        return value;
    }
    (0, utils_1.assert)(value.startsWith('bip39:'), 'Invalid HD path segment: The BIP-39 path must start with "bip39:".');
    return value.slice(6);
}
exports.multipathToBip39Mnemonic = multipathToBip39Mnemonic;
/**
 * Get a {@link RootedSLIP10SeedPathTuple} from a {@link RootedSLIP10PathTuple}.
 *
 * @param options - The options for getting the derivation path.
 * @param options.path - The derivation path to convert.
 * @param options.curve - The curve to use for derivation.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The derivation path with the seed, or entropy in the case of CIP-3.
 */
async function getDerivationPathWithSeed({ path, curve: curveName }, cryptographicFunctions) {
    const [mnemonicPhrase, ...rest] = path;
    const plainMnemonicPhrase = multipathToBip39Mnemonic(mnemonicPhrase);
    const curve = (0, curves_1.getCurveByName)(curveName);
    switch (curve.masterNodeGenerationSpec) {
        case 'slip10': {
            const seed = await mnemonicToSeed(plainMnemonicPhrase, '', cryptographicFunctions);
            return [seed, ...rest];
        }
        case 'cip3': {
            const seed = (0, scure_bip39_1.mnemonicToEntropy)(plainMnemonicPhrase, english_1.wordlist);
            return [seed, ...rest];
        }
        /* istanbul ignore next */
        default:
            return (0, utils_1.assertExhaustive)(curve);
    }
}
exports.getDerivationPathWithSeed = getDerivationPathWithSeed;
/**
 * Create a {@link SLIP10Node} from a BIP-39 seed.
 *
 * @param options - The options for creating the node.
 * @param options.path - The multi path. This is expected to be the BIP-39 seed,
 * or the entropy in the case of CIP-3, not the mnemonic phrase itself.
 * @param options.curve - The curve to use for derivation.
 * @param options.network - The network for the node. This is only used for
 * extended keys, and defaults to `mainnet`.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The node.
 */
async function deriveChildKey({ path, curve, network }, cryptographicFunctions) {
    (0, utils_1.assert)(path instanceof Uint8Array, 'Invalid path: The path must be a Uint8Array.');
    switch (curve.masterNodeGenerationSpec) {
        case 'slip10':
            return createBip39KeyFromSeed(path, curve, network, cryptographicFunctions);
        case 'cip3':
            return entropyToCip3MasterNode(path, curve, network, cryptographicFunctions);
        default:
            throw new Error('Unsupported master node generation spec.');
    }
}
exports.deriveChildKey = deriveChildKey;
/**
 * Create a {@link SLIP10Node} from a BIP-39 seed.
 *
 * @param seed - The cryptographic seed bytes.
 * @param curve - The curve to use.
 * @param network - The network for the node. This is only used for extended
 * keys, and defaults to `mainnet`.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns An object containing the corresponding BIP-39 master key and chain
 * code.
 */
async function createBip39KeyFromSeed(seed, curve, network, cryptographicFunctions) {
    (0, utils_1.assert)(seed.length >= 16 && seed.length <= 64, 'Invalid seed: The seed must be between 16 and 64 bytes long.');
    const key = await (0, cryptography_1.hmacSha512)(curve.secret, seed, cryptographicFunctions);
    const privateKey = key.slice(0, constants_1.BYTES_KEY_LENGTH);
    const chainCode = key.slice(constants_1.BYTES_KEY_LENGTH);
    (0, utils_1.assert)(curve.isValidPrivateKey(privateKey), 'Invalid private key: The private key must greater than 0 and less than the curve order.');
    const publicKey = curve.getPublicKey(privateKey, false);
    const masterFingerprint = (0, utils_2.getFingerprint)(curve.compressPublicKey(publicKey), curve.compressedPublicKeyLength);
    return SLIP10Node_1.SLIP10Node.fromExtendedKey({
        privateKey,
        publicKey,
        chainCode,
        masterFingerprint,
        network,
        depth: 0,
        parentFingerprint: 0,
        index: 0,
        curve: curve.name,
        guard: guard_1.PUBLIC_KEY_GUARD,
    }, cryptographicFunctions);
}
exports.createBip39KeyFromSeed = createBip39KeyFromSeed;
/**
 * Create a {@link SLIP10Node} from BIP-39 entropy.
 * This function is consistent with the Icarus derivation scheme.
 * Icarus root key derivation scheme: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.
 * CIP3: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.
 *
 * @param entropy - The entropy value.
 * @param curve - The curve to use.
 * @param network - The network for the node. This is only used for extended
 * keys, and defaults to `mainnet`.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.
 */
async function entropyToCip3MasterNode(entropy, curve, network, cryptographicFunctions) {
    (0, utils_1.assert)(entropy.length >= 16 && entropy.length <= 64, 'Invalid entropy: The entropy must be between 16 and 64 bytes long.');
    const rootNode = await (0, cryptography_1.pbkdf2Sha512)(curve.secret, entropy, 4096, 96, cryptographicFunctions);
    // Consistent with the Icarus derivation scheme.
    // https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md
    /* eslint-disable no-bitwise */
    rootNode[0] &= 248;
    rootNode[31] &= 31;
    rootNode[31] |= 64;
    /* eslint-enable no-bitwise */
    const privateKey = rootNode.slice(0, curve.privateKeyLength);
    const chainCode = rootNode.slice(curve.privateKeyLength);
    (0, utils_1.assert)(curve.isValidPrivateKey(privateKey), 'Invalid private key.');
    const publicKey = curve.getPublicKey(privateKey, false);
    const masterFingerprint = (0, utils_2.getFingerprint)(curve.compressPublicKey(publicKey), curve.compressedPublicKeyLength);
    return SLIP10Node_1.SLIP10Node.fromExtendedKey({
        privateKey,
        publicKey,
        chainCode,
        masterFingerprint,
        network,
        depth: 0,
        parentFingerprint: 0,
        index: 0,
        curve: curve.name,
        guard: guard_1.PUBLIC_KEY_GUARD,
    }, cryptographicFunctions);
}
exports.entropyToCip3MasterNode = entropyToCip3MasterNode;
//# sourceMappingURL=bip39.cjs.map