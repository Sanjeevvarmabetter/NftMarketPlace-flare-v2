{"version":3,"file":"bip39.mjs","sourceRoot":"","sources":["../../src/derivers/bip39.ts"],"names":[],"mappings":"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","sourcesContent":["import { mnemonicToEntropy } from '@metamask/scure-bip39';\nimport { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert, assertExhaustive, stringToBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport type {\n  BIP39Node,\n  BIP39StringNode,\n  Network,\n  RootedSLIP10PathTuple,\n  RootedSLIP10SeedPathTuple,\n} from '../constants';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { hmacSha512, pbkdf2Sha512 } from '../cryptography';\nimport type { Curve, SupportedCurve } from '../curves';\nimport { getCurveByName } from '../curves';\nimport { PUBLIC_KEY_GUARD } from '../guard';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { getFingerprint } from '../utils';\n\nconst MNEMONIC_PHRASE_LENGTHS = [12, 15, 18, 21, 24];\n\n/**\n * Validate a BIP-39 mnemonic phrase. The phrase must:\n *\n * - Consist of 12, 15, 18, 21, or 24 words.\n * - Contain only words from the English wordlist.\n *\n * @param mnemonicPhrase - The mnemonic phrase to validate.\n * @throws If the mnemonic phrase is invalid.\n */\nfunction validateMnemonicPhrase(mnemonicPhrase: string): void {\n  const words = mnemonicPhrase.split(' ');\n\n  assert(\n    MNEMONIC_PHRASE_LENGTHS.includes(words.length),\n    `Invalid mnemonic phrase: The mnemonic phrase must consist of 12, 15, 18, 21, or 24 words.`,\n  );\n\n  assert(\n    words.every((word) => englishWordlist.includes(word)),\n    'Invalid mnemonic phrase: The mnemonic phrase contains an unknown word.',\n  );\n}\n\n/**\n * Encode a BIP-39 mnemonic phrase to a `Uint8Array` for use in seed generation.\n * If the mnemonic is already a `Uint8Array`, it is assumed to contain the\n * indices of the words in the wordlist.\n *\n * @param mnemonic - The mnemonic phrase to encode.\n * @param wordlist - The wordlist to use.\n * @returns The encoded mnemonic phrase.\n */\nfunction encodeMnemonicPhrase(\n  mnemonic: string | Uint8Array,\n  wordlist: string[],\n): Uint8Array {\n  if (typeof mnemonic === 'string') {\n    validateMnemonicPhrase(mnemonic);\n    return stringToBytes(mnemonic.normalize('NFKD'));\n  }\n\n  const mnemonicString = Array.from(new Uint16Array(mnemonic.buffer))\n    .map((i) => wordlist[i])\n    .join(' ');\n\n  validateMnemonicPhrase(mnemonicString);\n  return stringToBytes(mnemonicString);\n}\n\n/**\n * Convert a BIP-39 mnemonic phrase to a seed.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert. If the mnemonic is a\n * `Uint8Array`, it is assumed to contain the indices of the words in the\n * English wordlist.\n * @param passphrase - The passphrase to use.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The seed.\n */\nexport async function mnemonicToSeed(\n  mnemonic: string | Uint8Array,\n  passphrase = '',\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> {\n  const salt = `mnemonic${passphrase}`.normalize('NFKD');\n  return await pbkdf2Sha512(\n    encodeMnemonicPhrase(mnemonic, englishWordlist),\n    stringToBytes(salt),\n    2048,\n    64,\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Convert a BIP-39 mnemonic phrase to a multi path.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert.\n * @returns The multi path.\n */\nexport function bip39MnemonicToMultipath(mnemonic: string): BIP39StringNode {\n  return `bip39:${mnemonic.toLowerCase().trim()}`;\n}\n\n/**\n * Convert a multi path to a BIP-39 mnemonic phrase.\n *\n * @param value - The multi path to convert.\n * @returns The BIP-39 mnemonic phrase.\n */\nexport function multipathToBip39Mnemonic(\n  value: BIP39Node,\n): string | Uint8Array {\n  if (value instanceof Uint8Array) {\n    return value;\n  }\n\n  assert(\n    value.startsWith('bip39:'),\n    'Invalid HD path segment: The BIP-39 path must start with \"bip39:\".',\n  );\n\n  return value.slice(6);\n}\n\nexport type GetDerivationPathWithSeedOptions = {\n  path: RootedSLIP10PathTuple;\n  curve: SupportedCurve;\n};\n\n/**\n * Get a {@link RootedSLIP10SeedPathTuple} from a {@link RootedSLIP10PathTuple}.\n *\n * @param options - The options for getting the derivation path.\n * @param options.path - The derivation path to convert.\n * @param options.curve - The curve to use for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derivation path with the seed, or entropy in the case of CIP-3.\n */\nexport async function getDerivationPathWithSeed(\n  { path, curve: curveName }: GetDerivationPathWithSeedOptions,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<RootedSLIP10SeedPathTuple> {\n  const [mnemonicPhrase, ...rest] = path;\n  const plainMnemonicPhrase = multipathToBip39Mnemonic(mnemonicPhrase);\n\n  const curve = getCurveByName(curveName);\n  switch (curve.masterNodeGenerationSpec) {\n    case 'slip10': {\n      const seed = await mnemonicToSeed(\n        plainMnemonicPhrase,\n        '',\n        cryptographicFunctions,\n      );\n      return [seed, ...rest];\n    }\n\n    case 'cip3': {\n      const seed = mnemonicToEntropy(plainMnemonicPhrase, englishWordlist);\n      return [seed, ...rest];\n    }\n\n    /* istanbul ignore next */\n    default:\n      return assertExhaustive(curve);\n  }\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 seed.\n *\n * @param options - The options for creating the node.\n * @param options.path - The multi path. This is expected to be the BIP-39 seed,\n * or the entropy in the case of CIP-3, not the mnemonic phrase itself.\n * @param options.curve - The curve to use for derivation.\n * @param options.network - The network for the node. This is only used for\n * extended keys, and defaults to `mainnet`.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The node.\n */\nexport async function deriveChildKey(\n  { path, curve, network }: DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    path instanceof Uint8Array,\n    'Invalid path: The path must be a Uint8Array.',\n  );\n\n  switch (curve.masterNodeGenerationSpec) {\n    case 'slip10':\n      return createBip39KeyFromSeed(\n        path,\n        curve,\n        network,\n        cryptographicFunctions,\n      );\n    case 'cip3':\n      return entropyToCip3MasterNode(\n        path,\n        curve,\n        network,\n        cryptographicFunctions,\n      );\n    default:\n      throw new Error('Unsupported master node generation spec.');\n  }\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 seed.\n *\n * @param seed - The cryptographic seed bytes.\n * @param curve - The curve to use.\n * @param network - The network for the node. This is only used for extended\n * keys, and defaults to `mainnet`.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns An object containing the corresponding BIP-39 master key and chain\n * code.\n */\nexport async function createBip39KeyFromSeed(\n  seed: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'slip10' }>,\n  network?: Network | undefined,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    seed.length >= 16 && seed.length <= 64,\n    'Invalid seed: The seed must be between 16 and 64 bytes long.',\n  );\n\n  const key = await hmacSha512(curve.secret, seed, cryptographicFunctions);\n  const privateKey = key.slice(0, BYTES_KEY_LENGTH);\n  const chainCode = key.slice(BYTES_KEY_LENGTH);\n\n  assert(\n    curve.isValidPrivateKey(privateKey),\n    'Invalid private key: The private key must greater than 0 and less than the curve order.',\n  );\n\n  const publicKey = curve.getPublicKey(privateKey, false);\n  const masterFingerprint = getFingerprint(\n    curve.compressPublicKey(publicKey),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      privateKey,\n      publicKey,\n      chainCode,\n      masterFingerprint,\n      network,\n      depth: 0,\n      parentFingerprint: 0,\n      index: 0,\n      curve: curve.name,\n      guard: PUBLIC_KEY_GUARD,\n    },\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Create a {@link SLIP10Node} from BIP-39 entropy.\n * This function is consistent with the Icarus derivation scheme.\n * Icarus root key derivation scheme: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n * CIP3: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * @param entropy - The entropy value.\n * @param curve - The curve to use.\n * @param network - The network for the node. This is only used for extended\n * keys, and defaults to `mainnet`.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.\n */\nexport async function entropyToCip3MasterNode(\n  entropy: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'cip3' }>,\n  network?: Network | undefined,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    entropy.length >= 16 && entropy.length <= 64,\n    'Invalid entropy: The entropy must be between 16 and 64 bytes long.',\n  );\n\n  const rootNode = await pbkdf2Sha512(\n    curve.secret,\n    entropy,\n    4096,\n    96,\n    cryptographicFunctions,\n  );\n\n  // Consistent with the Icarus derivation scheme.\n  // https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md\n  /* eslint-disable no-bitwise */\n  rootNode[0] &= 0b1111_1000;\n  rootNode[31] &= 0b0001_1111;\n  rootNode[31] |= 0b0100_0000;\n  /* eslint-enable no-bitwise */\n\n  const privateKey = rootNode.slice(0, curve.privateKeyLength);\n  const chainCode = rootNode.slice(curve.privateKeyLength);\n\n  assert(curve.isValidPrivateKey(privateKey), 'Invalid private key.');\n\n  const publicKey = curve.getPublicKey(privateKey, false);\n  const masterFingerprint = getFingerprint(\n    curve.compressPublicKey(publicKey),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      privateKey,\n      publicKey,\n      chainCode,\n      masterFingerprint,\n      network,\n      depth: 0,\n      parentFingerprint: 0,\n      index: 0,\n      curve: curve.name,\n      guard: PUBLIC_KEY_GUARD,\n    },\n    cryptographicFunctions,\n  );\n}\n"]}