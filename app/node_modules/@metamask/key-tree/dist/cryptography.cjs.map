{"version":3,"file":"cryptography.cjs","sourceRoot":"","sources":["../src/cryptography.ts"],"names":[],"mappings":";;;AAAA,6CAAuD;AACvD,iDAAkE;AAClE,uDAAsE;AACtE,iDAA6D;AAC7D,6CAAkE;AAClE,iDAA6D;AAE7D,uCAA+C;AA8B/C;;;;;;;;;;;GAWG;AACI,KAAK,UAAU,UAAU,CAC9B,GAAe,EACf,IAAgB,EAChB,yBAAiD,EAAE;IAEnD,IAAI,sBAAsB,CAAC,UAAU,EAAE,CAAC;QACtC,OAAO,MAAM,sBAAsB,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;IAC5D,CAAC;IAED,IAAI,IAAA,4BAAoB,GAAE,EAAE,CAAC;QAC3B,0CAA0C;QAC1C,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CAC7C,KAAK,EACL,GAAG,EACH,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,EACjC,KAAK,EACL,CAAC,MAAM,CAAC,CACT,CAAC;QAEF,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;QACjE,OAAO,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;QAC9B,yCAAyC;IAC3C,CAAC;IAED,OAAO,IAAA,WAAS,EAAC,eAAW,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;AAC3C,CAAC;AAzBD,gCAyBC;AAED;;;;;;;;;GASG;AACH,SAAgB,SAAS,CAAC,IAAgB;IACxC,OAAO,IAAA,iBAAc,EAAC,IAAI,CAAC,CAAC;AAC9B,CAAC;AAFD,8BAEC;AAED;;;;;;;;;;;GAWG;AACI,KAAK,UAAU,YAAY,CAChC,QAAoB,EACpB,IAAgB,EAChB,UAAkB,EAClB,SAAiB,EACjB,yBAAiD,EAAE;IAEnD,IAAI,sBAAsB,CAAC,YAAY,EAAE,CAAC;QACxC,OAAO,MAAM,sBAAsB,CAAC,YAAY,CAC9C,QAAQ,EACR,IAAI,EACJ,UAAU,EACV,SAAS,CACV,CAAC;IACJ,CAAC;IAED,IAAI,IAAA,4BAAoB,GAAE,EAAE,CAAC;QAC3B,0CAA0C;QAC1C,MAAM,GAAG,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CACvC,KAAK,EACL,QAAQ,EACR,EAAE,IAAI,EAAE,QAAQ,EAAE,EAClB,KAAK,EACL,CAAC,YAAY,CAAC,CACf,CAAC;QAEF,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,UAAU,CAChD;YACE,IAAI,EAAE,QAAQ;YACd,IAAI;YACJ,UAAU;YACV,IAAI,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE;SAC1B,EACD,GAAG;QACH,mEAAmE;QACnE,uCAAuC;QACvC,SAAS,GAAG,CAAC,CACd,CAAC;QAEF,OAAO,IAAI,UAAU,CAAC,WAAW,CAAC,CAAC;QACnC,yCAAyC;IAC3C,CAAC;IAED,OAAO,MAAM,IAAA,oBAAW,EAAC,eAAW,EAAE,QAAQ,EAAE,IAAI,EAAE;QACpD,CAAC,EAAE,UAAU;QACb,KAAK,EAAE,SAAS;KACjB,CAAC,CAAC;AACL,CAAC;AA/CD,oCA+CC;AAED;;;;;;;;;GASG;AACH,SAAgB,SAAS,CAAC,IAAgB;IACxC,OAAO,IAAA,qBAAc,EAAC,IAAI,CAAC,CAAC;AAC9B,CAAC;AAFD,8BAEC;AAED;;;;;;;;;GASG;AACH,SAAgB,MAAM,CAAC,IAAgB;IACrC,OAAO,IAAA,eAAW,EAAC,IAAI,CAAC,CAAC;AAC3B,CAAC;AAFD,wBAEC","sourcesContent":["import { hmac as nobleHmac } from '@noble/hashes/hmac';\nimport { pbkdf2Async as noblePbkdf2 } from '@noble/hashes/pbkdf2';\nimport { ripemd160 as nobleRipemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 as nobleSha256 } from '@noble/hashes/sha256';\nimport { keccak_256 as nobleKeccak256 } from '@noble/hashes/sha3';\nimport { sha512 as nobleSha512 } from '@noble/hashes/sha512';\n\nimport { isWebCryptoSupported } from './utils';\n\nexport type CryptographicFunctions = {\n  /**\n   * Compute the HMAC-SHA-512 of the given data using the given key.\n   *\n   * @param key - The key to use.\n   * @param data - The data to hash.\n   * @returns The HMAC-SHA-512 of the data.\n   */\n  hmacSha512?: (key: Uint8Array, data: Uint8Array) => Promise<Uint8Array>;\n\n  /**\n   * Compute the PBKDF2 of the given password, salt, iterations, and key length.\n   * The hash function used is SHA-512.\n   *\n   * @param password - The password to hash.\n   * @param salt - The salt to use.\n   * @param iterations - The number of iterations.\n   * @param keyLength - The desired key length in bytes.\n   * @returns The PBKDF2 of the password.\n   */\n  pbkdf2Sha512?: (\n    password: Uint8Array,\n    salt: Uint8Array,\n    iterations: number,\n    keyLength: number,\n  ) => Promise<Uint8Array>;\n};\n\n/**\n * Compute the HMAC-SHA-512 of the given data using the given key.\n *\n * This function uses the Web Crypto API if available, falling back to a\n * JavaScript implementation if not.\n *\n * @param key - The key to use.\n * @param data - The data to hash.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The HMAC-SHA-512 of the data.\n */\nexport async function hmacSha512(\n  key: Uint8Array,\n  data: Uint8Array,\n  cryptographicFunctions: CryptographicFunctions = {},\n): Promise<Uint8Array> {\n  if (cryptographicFunctions.hmacSha512) {\n    return await cryptographicFunctions.hmacSha512(key, data);\n  }\n\n  if (isWebCryptoSupported()) {\n    /* eslint-disable no-restricted-globals */\n    const subtleKey = await crypto.subtle.importKey(\n      'raw',\n      key,\n      { name: 'HMAC', hash: 'SHA-512' },\n      false,\n      ['sign'],\n    );\n\n    const result = await crypto.subtle.sign('HMAC', subtleKey, data);\n    return new Uint8Array(result);\n    /* eslint-enable no-restricted-globals */\n  }\n\n  return nobleHmac(nobleSha512, key, data);\n}\n\n/**\n * Compute the Keccak-256 of the given data synchronously.\n *\n * Right now this is just a wrapper around `keccak256` from the `@noble/hashes`\n * package, but it's here in case we want to change the implementation in the\n * future to allow for asynchronous hashing.\n *\n * @param data - The data to hash.\n * @returns The Keccak-256 of the data.\n */\nexport function keccak256(data: Uint8Array): Uint8Array {\n  return nobleKeccak256(data);\n}\n\n/**\n * Compute the PBKDF2 of the given password, salt, iterations, and key length.\n * The hash function used is SHA-512.\n *\n * @param password - The password to hash.\n * @param salt - The salt to use.\n * @param iterations - The number of iterations.\n * @param keyLength - The desired key length.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The PBKDF2 of the password.\n */\nexport async function pbkdf2Sha512(\n  password: Uint8Array,\n  salt: Uint8Array,\n  iterations: number,\n  keyLength: number,\n  cryptographicFunctions: CryptographicFunctions = {},\n): Promise<Uint8Array> {\n  if (cryptographicFunctions.pbkdf2Sha512) {\n    return await cryptographicFunctions.pbkdf2Sha512(\n      password,\n      salt,\n      iterations,\n      keyLength,\n    );\n  }\n\n  if (isWebCryptoSupported()) {\n    /* eslint-disable no-restricted-globals */\n    const key = await crypto.subtle.importKey(\n      'raw',\n      password,\n      { name: 'PBKDF2' },\n      false,\n      ['deriveBits'],\n    );\n\n    const derivedBits = await crypto.subtle.deriveBits(\n      {\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: { name: 'SHA-512' },\n      },\n      key,\n      // `keyLength` is the number of bytes, but `deriveBits` expects the\n      // number of bits, so we multiply by 8.\n      keyLength * 8,\n    );\n\n    return new Uint8Array(derivedBits);\n    /* eslint-enable no-restricted-globals */\n  }\n\n  return await noblePbkdf2(nobleSha512, password, salt, {\n    c: iterations,\n    dkLen: keyLength,\n  });\n}\n\n/**\n * Compute the RIPEMD-160 of the given data.\n *\n * Right now this is just a wrapper around `ripemd160` from the `@noble/hashes`\n * package, but it's here in case we want to change the implementation in the\n * future to allow for asynchronous hashing.\n *\n * @param data - The data to hash.\n * @returns The RIPEMD-160 of the data.\n */\nexport function ripemd160(data: Uint8Array): Uint8Array {\n  return nobleRipemd160(data);\n}\n\n/**\n * Compute the SHA-256 of the given data synchronously.\n *\n * Right now this is just a wrapper around `sha256` from the `@noble/hashes`\n * package, but it's here in case we want to change the implementation in the\n * future to allow for asynchronous hashing.\n *\n * @param data - The data to hash.\n * @returns The SHA-256 of the data.\n */\nexport function sha256(data: Uint8Array): Uint8Array {\n  return nobleSha256(data);\n}\n"]}