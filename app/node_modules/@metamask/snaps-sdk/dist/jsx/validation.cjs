"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpinnerStruct = exports.RowStruct = exports.BannerStruct = exports.TooltipStruct = exports.TooltipContentStruct = exports.TooltipChildStruct = exports.ValueStruct = exports.TextStruct = exports.SkeletonStruct = exports.LinkStruct = exports.HeadingStruct = exports.DividerStruct = exports.CopyableStruct = exports.FooterStruct = exports.FooterChildStruct = exports.SectionStruct = exports.FormStruct = exports.FormChildStruct = exports.BoxStruct = exports.BoxChildrenStruct = exports.AvatarStruct = exports.FormattingStruct = exports.ItalicStruct = exports.BoldStruct = exports.FieldStruct = exports.FieldChildUnionStruct = exports.FileInputStruct = exports.RadioGroupStruct = exports.RadioStruct = exports.AssetSelectorStruct = exports.SelectorStruct = exports.SelectorOptionStruct = exports.CardStruct = exports.AddressStruct = exports.DropdownStruct = exports.OptionStruct = exports.AddressInputStruct = exports.InputStruct = exports.NumberInputPropsStruct = exports.PasswordInputPropsStruct = exports.TextInputPropsStruct = exports.GenericInputPropsStruct = exports.CheckboxStruct = exports.ButtonStruct = exports.IconStruct = exports.ImageStruct = exports.BorderRadiusStruct = exports.ElementStruct = exports.StringElementStruct = exports.KeyStruct = void 0;
exports.assertJSXElement = exports.isJSXElementUnsafe = exports.isJSXElement = exports.JSXElementStruct = exports.RootJSXElementStruct = exports.ContainerStruct = exports.BoxChildStruct = void 0;
const superstruct_1 = require("@metamask/superstruct");
const utils_1 = require("@metamask/utils");
const components_1 = require("./components/index.cjs");
const internals_1 = require("../internals/index.cjs");
const types_1 = require("../types/index.cjs");
/**
 * A struct for the {@link Key} type.
 */
exports.KeyStruct = (0, internals_1.nullUnion)([(0, superstruct_1.string)(), (0, superstruct_1.number)()]);
/**
 * A struct for the {@link StringElement} type.
 */
exports.StringElementStruct = children([
    (0, superstruct_1.string)(),
]);
/**
 * A struct for the {@link GenericSnapElement} type.
 */
exports.ElementStruct = (0, superstruct_1.object)({
    type: (0, superstruct_1.string)(),
    props: (0, superstruct_1.record)((0, superstruct_1.string)(), utils_1.JsonStruct),
    key: (0, superstruct_1.nullable)(exports.KeyStruct),
});
/**
 * A helper function for creating a struct for a {@link Nestable} type.
 *
 * @param struct - The struct for the type to test.
 * @returns The struct for the nestable type.
 */
function nestable(struct) {
    const nestableStruct = (0, internals_1.selectiveUnion)((value) => {
        if (Array.isArray(value)) {
            return (0, superstruct_1.array)((0, superstruct_1.lazy)(() => nestableStruct));
        }
        return struct;
    });
    return nestableStruct;
}
/**
 * A helper function for creating a struct which allows children of a specific
 * type, as well as `null` and `boolean`.
 *
 * @param structs - The structs to allow as children.
 * @returns The struct for the children.
 */
function children(structs) {
    const potentialUnion = structs.length === 1 ? structs[0] : (0, internals_1.nullUnion)(structs);
    return nestable((0, superstruct_1.nullable)((0, internals_1.selectiveUnion)((value) => {
        if (typeof value === 'boolean') {
            return (0, superstruct_1.boolean)();
        }
        return potentialUnion;
    })));
}
/**
 * A helper function for creating a struct which allows a single child of a specific
 * type, as well as `null` and `boolean`.
 *
 * @param struct - The struct to allow as a single child.
 * @returns The struct for the children.
 */
function singleChild(struct) {
    return (0, superstruct_1.nullable)((0, internals_1.selectiveUnion)((value) => {
        if (typeof value === 'boolean') {
            return (0, superstruct_1.boolean)();
        }
        return struct;
    }));
}
/**
 * A helper function for creating a struct for a JSX element.
 *
 * @param name - The name of the element.
 * @param props - The props of the element.
 * @returns The struct for the element.
 */
function element(name, props = {}) {
    return (0, superstruct_1.object)({
        type: (0, internals_1.literal)(name),
        props: (0, superstruct_1.object)(props),
        key: (0, superstruct_1.nullable)(exports.KeyStruct),
    });
}
/**
 * A helper function for creating a struct for a JSX element with selective props.
 *
 * @param name - The name of the element.
 * @param selector - The selector function choosing the struct to validate with.
 * @returns The struct for the element.
 */
function elementWithSelectiveProps(name, selector) {
    return (0, superstruct_1.object)({
        type: (0, internals_1.literal)(name),
        props: (0, internals_1.selectiveUnion)(selector),
        key: (0, superstruct_1.nullable)(exports.KeyStruct),
    });
}
/**
 * Shared struct used to validate border radius values used by various Snaps components.
 */
exports.BorderRadiusStruct = (0, internals_1.nullUnion)([
    (0, internals_1.literal)('none'),
    (0, internals_1.literal)('medium'),
    (0, internals_1.literal)('full'),
]);
/**
 * A struct for the {@link ImageElement} type.
 */
exports.ImageStruct = element('Image', {
    src: (0, internals_1.svg)(),
    alt: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    borderRadius: (0, superstruct_1.optional)(exports.BorderRadiusStruct),
});
const IconNameStruct = (0, internals_1.nullUnion)(Object.values(components_1.IconName).map((name) => (0, internals_1.literal)(name)));
/**
 * A struct for the {@link IconElement} type.
 */
exports.IconStruct = element('Icon', {
    name: IconNameStruct,
    color: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('default'), (0, internals_1.literal)('primary'), (0, internals_1.literal)('muted')])),
    size: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('md'), (0, internals_1.literal)('inherit')])),
});
/**
 * A struct for the {@link ButtonElement} type.
 */
exports.ButtonStruct = element('Button', {
    children: children([exports.StringElementStruct, exports.ImageStruct, exports.IconStruct]),
    name: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    type: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('button'), (0, internals_1.literal)('submit')])),
    variant: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('primary'), (0, internals_1.literal)('destructive')])),
    size: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('sm'), (0, internals_1.literal)('md')])),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
    loading: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
    form: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
/**
 * A struct for the {@link CheckboxElement} type.
 */
exports.CheckboxStruct = element('Checkbox', {
    name: (0, superstruct_1.string)(),
    checked: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
    label: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    variant: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('default'), (0, internals_1.literal)('toggle')])),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the generic input element props.
 */
exports.GenericInputPropsStruct = (0, superstruct_1.object)({
    name: (0, superstruct_1.string)(),
    value: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    placeholder: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the text type input props.
 */
exports.TextInputPropsStruct = (0, superstruct_1.assign)(exports.GenericInputPropsStruct, (0, superstruct_1.object)({
    type: (0, internals_1.literal)('text'),
}));
/**
 * A struct for the password type input props.
 */
exports.PasswordInputPropsStruct = (0, superstruct_1.assign)(exports.GenericInputPropsStruct, (0, superstruct_1.object)({
    type: (0, internals_1.literal)('password'),
}));
/**
 * A struct for the number type input props.
 */
exports.NumberInputPropsStruct = (0, superstruct_1.assign)(exports.GenericInputPropsStruct, (0, superstruct_1.object)({
    type: (0, internals_1.literal)('number'),
    min: (0, superstruct_1.optional)((0, superstruct_1.number)()),
    max: (0, superstruct_1.optional)((0, superstruct_1.number)()),
    step: (0, superstruct_1.optional)((0, superstruct_1.number)()),
}));
/**
 * A struct for the {@link InputElement} type.
 */
exports.InputStruct = elementWithSelectiveProps('Input', (value) => {
    if ((0, utils_1.isPlainObject)(value) && (0, utils_1.hasProperty)(value, 'type')) {
        switch (value.type) {
            case 'text':
                return exports.TextInputPropsStruct;
            case 'password':
                return exports.PasswordInputPropsStruct;
            case 'number':
                return exports.NumberInputPropsStruct;
            default:
                return exports.GenericInputPropsStruct;
        }
    }
    return exports.GenericInputPropsStruct;
});
/**
 * A struct for the {@link AddressInputElement} type.
 */
exports.AddressInputStruct = element('AddressInput', {
    name: (0, superstruct_1.string)(),
    chainId: utils_1.CaipChainIdStruct,
    value: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    placeholder: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
    displayAvatar: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the {@link OptionElement} type.
 */
exports.OptionStruct = element('Option', {
    value: (0, superstruct_1.string)(),
    children: (0, superstruct_1.string)(),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the {@link DropdownElement} type.
 */
exports.DropdownStruct = element('Dropdown', {
    name: (0, superstruct_1.string)(),
    value: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    children: children([exports.OptionStruct]),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the {@link AddressElement} type.
 */
exports.AddressStruct = element('Address', {
    address: (0, internals_1.selectiveUnion)((value) => {
        if (typeof value === 'string' && value.startsWith('0x')) {
            return utils_1.HexChecksumAddressStruct;
        }
        return utils_1.CaipAccountIdStruct;
    }),
    truncate: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
    displayName: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
    avatar: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the {@link CardElement} type.
 */
exports.CardStruct = element('Card', {
    image: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    title: (0, internals_1.selectiveUnion)((value) => {
        if (typeof value === 'object') {
            return exports.AddressStruct;
        }
        return (0, superstruct_1.string)();
    }),
    description: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    value: (0, superstruct_1.string)(),
    extra: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
/**
 * A struct for the {@link SelectorOptionElement} type.
 */
exports.SelectorOptionStruct = element('SelectorOption', {
    value: (0, superstruct_1.string)(),
    children: exports.CardStruct,
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the {@link SelectorElement} type.
 */
exports.SelectorStruct = element('Selector', {
    name: (0, superstruct_1.string)(),
    title: (0, superstruct_1.string)(),
    value: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    children: children([exports.SelectorOptionStruct]),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the {@link AssetSelectorElement} type.
 */
exports.AssetSelectorStruct = element('AssetSelector', {
    name: (0, superstruct_1.string)(),
    addresses: types_1.NonEip155CaipAccountIdsMatchedByAddressAndNamespaceStruct,
    chainIds: (0, superstruct_1.optional)((0, superstruct_1.array)(types_1.NonEip155ChainIdStruct)),
    value: (0, superstruct_1.optional)(types_1.NonEip155AssetTypeStruct),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the {@link RadioElement} type.
 */
exports.RadioStruct = element('Radio', {
    value: (0, superstruct_1.string)(),
    children: (0, superstruct_1.string)(),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the {@link RadioGroupElement} type.
 */
exports.RadioGroupStruct = element('RadioGroup', {
    name: (0, superstruct_1.string)(),
    value: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    children: children([exports.RadioStruct]),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the {@link FileInputElement} type.
 */
exports.FileInputStruct = element('FileInput', {
    name: (0, superstruct_1.string)(),
    accept: (0, internals_1.nullUnion)([(0, superstruct_1.optional)((0, superstruct_1.array)((0, superstruct_1.string)()))]),
    compact: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
    disabled: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A subset of JSX elements that represent the tuple Box + Input of the Field children.
 */
const BOX_INPUT_LEFT = [
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    singleChild((0, superstruct_1.lazy)(() => exports.BoxChildStruct)),
    exports.InputStruct,
];
/**
 * A subset of JSX elements that represent the tuple Input + Box of the Field children.
 */
const BOX_INPUT_RIGHT = [
    exports.InputStruct,
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    singleChild((0, superstruct_1.lazy)(() => exports.BoxChildStruct)),
];
/**
 * A subset of JSX elements that represent the tuple Box + Input + Box of the Field children.
 */
const BOX_INPUT_BOTH = [
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    singleChild((0, superstruct_1.lazy)(() => exports.BoxChildStruct)),
    exports.InputStruct,
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    singleChild((0, superstruct_1.lazy)(() => exports.BoxChildStruct)),
];
/**
 * A subset of JSX elements that are allowed as single children of the Field component.
 */
const FIELD_CHILDREN_ARRAY = [
    exports.AssetSelectorStruct,
    exports.AddressInputStruct,
    exports.InputStruct,
    exports.DropdownStruct,
    exports.RadioGroupStruct,
    exports.FileInputStruct,
    exports.CheckboxStruct,
    exports.SelectorStruct,
];
/**
 * A union of the allowed children of the Field component.
 * This is mainly used in the simulator for validation purposes.
 */
exports.FieldChildUnionStruct = (0, internals_1.nullUnion)([
    ...FIELD_CHILDREN_ARRAY,
    ...BOX_INPUT_LEFT,
    ...BOX_INPUT_RIGHT,
    ...BOX_INPUT_BOTH,
]);
/**
 * A subset of JSX elements that are allowed as children of the Field component.
 */
const FieldChildStruct = (0, internals_1.selectiveUnion)((value) => {
    const isArray = Array.isArray(value);
    if (isArray && value.length === 3) {
        return (0, superstruct_1.tuple)(BOX_INPUT_BOTH);
    }
    if (isArray && value.length === 2) {
        return value[0]?.type === 'Box'
            ? (0, superstruct_1.tuple)(BOX_INPUT_LEFT)
            : (0, superstruct_1.tuple)(BOX_INPUT_RIGHT);
    }
    return (0, internals_1.typedUnion)(FIELD_CHILDREN_ARRAY);
});
/**
 * A struct for the {@link FieldElement} type.
 */
exports.FieldStruct = element('Field', {
    label: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    error: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    children: FieldChildStruct,
});
/**
 * A struct for the {@link BoldElement} type.
 */
exports.BoldStruct = element('Bold', {
    children: children([
        (0, superstruct_1.string)(),
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        (0, superstruct_1.lazy)(() => exports.ItalicStruct),
    ]),
});
/**
 * A struct for the {@link ItalicElement} type.
 */
exports.ItalicStruct = element('Italic', {
    children: children([
        (0, superstruct_1.string)(),
        (0, superstruct_1.lazy)(() => exports.BoldStruct),
    ]),
});
exports.FormattingStruct = (0, internals_1.typedUnion)([exports.BoldStruct, exports.ItalicStruct]);
/**
 * A struct for the {@link AvatarElement} type.
 */
exports.AvatarStruct = element('Avatar', {
    address: utils_1.CaipAccountIdStruct,
    size: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('sm'), (0, internals_1.literal)('md'), (0, internals_1.literal)('lg')])),
});
exports.BoxChildrenStruct = children(
// eslint-disable-next-line @typescript-eslint/no-use-before-define
[(0, superstruct_1.lazy)(() => exports.BoxChildStruct)]);
/**
 * A struct for the {@link BoxElement} type.
 */
exports.BoxStruct = element('Box', {
    children: exports.BoxChildrenStruct,
    direction: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('horizontal'), (0, internals_1.literal)('vertical')])),
    alignment: (0, superstruct_1.optional)((0, internals_1.nullUnion)([
        (0, internals_1.literal)('start'),
        (0, internals_1.literal)('center'),
        (0, internals_1.literal)('end'),
        (0, internals_1.literal)('space-between'),
        (0, internals_1.literal)('space-around'),
    ])),
    crossAlignment: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('start'), (0, internals_1.literal)('center'), (0, internals_1.literal)('end')])),
    center: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A subset of JSX elements that are allowed as children of the Form component.
 */
exports.FormChildStruct = exports.BoxChildrenStruct;
/**
 * A struct for the {@link FormElement} type.
 */
exports.FormStruct = element('Form', {
    children: exports.FormChildStruct,
    name: (0, superstruct_1.string)(),
});
const FooterButtonStruct = (0, superstruct_1.refine)(exports.ButtonStruct, 'FooterButton', (value) => {
    if (typeof value.props.children === 'string' ||
        typeof value.props.children === 'boolean' ||
        value.props.children === null) {
        return true;
    }
    if (Array.isArray(value.props.children)) {
        const hasNonTextElements = value.props.children.some((child) => typeof child !== 'string' &&
            typeof child !== 'boolean' &&
            child !== null);
        if (!hasNonTextElements) {
            return true;
        }
    }
    return 'Footer buttons may only contain text.';
});
/**
 * A struct for the {@link SectionElement} type.
 */
exports.SectionStruct = element('Section', {
    children: exports.BoxChildrenStruct,
    direction: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('horizontal'), (0, internals_1.literal)('vertical')])),
    alignment: (0, superstruct_1.optional)((0, internals_1.nullUnion)([
        (0, internals_1.literal)('start'),
        (0, internals_1.literal)('center'),
        (0, internals_1.literal)('end'),
        (0, internals_1.literal)('space-between'),
        (0, internals_1.literal)('space-around'),
    ])),
});
/**
 * A subset of JSX elements that are allowed as children of the Footer component.
 * This set should include a single button or a tuple of two buttons.
 */
exports.FooterChildStruct = (0, internals_1.selectiveUnion)((value) => {
    if (Array.isArray(value)) {
        return (0, superstruct_1.tuple)([FooterButtonStruct, FooterButtonStruct]);
    }
    return FooterButtonStruct;
});
/**
 * A struct for the {@link FooterElement} type.
 */
exports.FooterStruct = element('Footer', {
    children: exports.FooterChildStruct,
});
/**
 * A struct for the {@link CopyableElement} type.
 */
exports.CopyableStruct = element('Copyable', {
    value: (0, superstruct_1.string)(),
    sensitive: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
});
/**
 * A struct for the {@link DividerElement} type.
 */
exports.DividerStruct = element('Divider');
/**
 * A struct for the {@link HeadingElement} type.
 */
exports.HeadingStruct = element('Heading', {
    children: exports.StringElementStruct,
    size: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('sm'), (0, internals_1.literal)('md'), (0, internals_1.literal)('lg')])),
});
/**
 * A struct for the {@link LinkElement} type.
 */
exports.LinkStruct = element('Link', {
    href: (0, superstruct_1.string)(),
    children: children([
        exports.FormattingStruct,
        (0, superstruct_1.string)(),
        exports.IconStruct,
        exports.ImageStruct,
        exports.AddressStruct,
    ]),
});
/**
 * A struct for the {@link SkeletonElement} type.
 */
exports.SkeletonStruct = element('Skeleton', {
    width: (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()])),
    height: (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()])),
    borderRadius: (0, superstruct_1.optional)(exports.BorderRadiusStruct),
});
/**
 * A struct for the {@link TextElement} type.
 */
exports.TextStruct = element('Text', {
    children: children([
        (0, internals_1.selectiveUnion)((value) => {
            if (typeof value === 'string') {
                return (0, superstruct_1.string)();
            }
            return (0, internals_1.typedUnion)([
                exports.BoldStruct,
                exports.ItalicStruct,
                exports.LinkStruct,
                exports.IconStruct,
                exports.SkeletonStruct,
            ]);
        }),
    ]),
    alignment: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('start'), (0, internals_1.literal)('center'), (0, internals_1.literal)('end')])),
    color: (0, superstruct_1.optional)((0, internals_1.nullUnion)([
        (0, internals_1.literal)('default'),
        (0, internals_1.literal)('alternative'),
        (0, internals_1.literal)('muted'),
        (0, internals_1.literal)('error'),
        (0, internals_1.literal)('success'),
        (0, internals_1.literal)('warning'),
    ])),
    size: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('sm'), (0, internals_1.literal)('md')])),
    fontWeight: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('regular'), (0, internals_1.literal)('medium'), (0, internals_1.literal)('bold')])),
});
/**
 * A struct for the {@link ValueElement} type.
 */
exports.ValueStruct = element('Value', {
    value: (0, internals_1.selectiveUnion)((value) => {
        if (typeof value === 'string') {
            return (0, superstruct_1.string)();
        }
        return exports.TextStruct;
    }),
    extra: (0, internals_1.selectiveUnion)((value) => {
        if (typeof value === 'string') {
            return (0, superstruct_1.string)();
        }
        return exports.TextStruct;
    }),
});
/**
 * A subset of JSX elements that are allowed as children of the Tooltip component.
 * This set should include all text components and the Image.
 */
exports.TooltipChildStruct = (0, internals_1.selectiveUnion)((value) => {
    if (typeof value === 'boolean') {
        return (0, superstruct_1.boolean)();
    }
    return (0, internals_1.typedUnion)([
        exports.TextStruct,
        exports.BoldStruct,
        exports.ItalicStruct,
        exports.LinkStruct,
        exports.ImageStruct,
        exports.IconStruct,
    ]);
});
/**
 * A subset of JSX elements that are allowed as content of the Tooltip component.
 * This set should include all text components.
 */
exports.TooltipContentStruct = (0, internals_1.selectiveUnion)((value) => {
    if (typeof value === 'string') {
        return (0, superstruct_1.string)();
    }
    return (0, internals_1.typedUnion)([
        exports.TextStruct,
        exports.BoldStruct,
        exports.ItalicStruct,
        exports.LinkStruct,
        exports.IconStruct,
    ]);
});
/**
 * A struct for the {@link TooltipElement} type.
 */
exports.TooltipStruct = element('Tooltip', {
    children: (0, superstruct_1.nullable)(exports.TooltipChildStruct),
    content: exports.TooltipContentStruct,
});
/**
 * A struct for the {@link BannerElement} type.
 */
exports.BannerStruct = element('Banner', {
    children: children([
        exports.TextStruct,
        exports.LinkStruct,
        exports.IconStruct,
        exports.ButtonStruct,
        exports.BoldStruct,
        exports.ItalicStruct,
        exports.SkeletonStruct,
    ]),
    title: (0, superstruct_1.string)(),
    severity: (0, superstruct_1.union)([
        (0, internals_1.literal)('danger'),
        (0, internals_1.literal)('info'),
        (0, internals_1.literal)('success'),
        (0, internals_1.literal)('warning'),
    ]),
});
/**
 * A struct for the {@link RowElement} type.
 */
exports.RowStruct = element('Row', {
    label: (0, superstruct_1.string)(),
    children: (0, internals_1.typedUnion)([
        exports.AddressStruct,
        exports.ImageStruct,
        exports.TextStruct,
        exports.ValueStruct,
        exports.LinkStruct,
        exports.SkeletonStruct,
    ]),
    variant: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('default'), (0, internals_1.literal)('warning'), (0, internals_1.literal)('critical')])),
    tooltip: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
/**
 * A struct for the {@link SpinnerElement} type.
 */
exports.SpinnerStruct = element('Spinner');
/**
 * A subset of JSX elements that are allowed as children of the Box component.
 * This set includes all components, except components that need to be nested in
 * another component (e.g., Field must be contained in a Form).
 */
exports.BoxChildStruct = (0, internals_1.typedUnion)([
    exports.AddressStruct,
    exports.AssetSelectorStruct,
    exports.AddressInputStruct,
    exports.BoldStruct,
    exports.BoxStruct,
    exports.ButtonStruct,
    exports.CopyableStruct,
    exports.DividerStruct,
    exports.DropdownStruct,
    exports.RadioGroupStruct,
    exports.FieldStruct,
    exports.FileInputStruct,
    exports.FormStruct,
    exports.HeadingStruct,
    exports.InputStruct,
    exports.ImageStruct,
    exports.ItalicStruct,
    exports.LinkStruct,
    exports.RowStruct,
    exports.SpinnerStruct,
    exports.TextStruct,
    exports.TooltipStruct,
    exports.CheckboxStruct,
    exports.CardStruct,
    exports.IconStruct,
    exports.SelectorStruct,
    exports.SectionStruct,
    exports.AvatarStruct,
    exports.BannerStruct,
    exports.SkeletonStruct,
]);
/**
 * A struct for the {@link ContainerElement} type.
 */
exports.ContainerStruct = element('Container', {
    children: (0, internals_1.selectiveUnion)((value) => {
        if (Array.isArray(value)) {
            return (0, superstruct_1.tuple)([exports.BoxChildStruct, exports.FooterStruct]);
        }
        return exports.BoxChildStruct;
    }),
    backgroundColor: (0, superstruct_1.optional)((0, internals_1.nullUnion)([(0, internals_1.literal)('default'), (0, internals_1.literal)('alternative')])),
});
/**
 * For now, the allowed JSX elements at the root are the same as the allowed
 * children of the Box component.
 */
exports.RootJSXElementStruct = (0, internals_1.typedUnion)([
    exports.BoxChildStruct,
    exports.ContainerStruct,
]);
/**
 * A struct for the {@link JSXElement} type.
 */
exports.JSXElementStruct = (0, internals_1.typedUnion)([
    exports.AssetSelectorStruct,
    exports.AddressInputStruct,
    exports.ButtonStruct,
    exports.InputStruct,
    exports.FileInputStruct,
    exports.FieldStruct,
    exports.FormStruct,
    exports.BoldStruct,
    exports.ItalicStruct,
    exports.AddressStruct,
    exports.BoxStruct,
    exports.CopyableStruct,
    exports.DividerStruct,
    exports.HeadingStruct,
    exports.ImageStruct,
    exports.LinkStruct,
    exports.RowStruct,
    exports.SpinnerStruct,
    exports.TextStruct,
    exports.DropdownStruct,
    exports.OptionStruct,
    exports.RadioGroupStruct,
    exports.RadioStruct,
    exports.ValueStruct,
    exports.TooltipStruct,
    exports.CheckboxStruct,
    exports.FooterStruct,
    exports.ContainerStruct,
    exports.CardStruct,
    exports.IconStruct,
    exports.SelectorStruct,
    exports.SelectorOptionStruct,
    exports.SectionStruct,
    exports.AvatarStruct,
    exports.BannerStruct,
    exports.SkeletonStruct,
]);
/**
 * Check if a value is a JSX element.
 *
 * @param value - The value to check.
 * @returns True if the value is a JSX element, false otherwise.
 */
function isJSXElement(value) {
    return (0, superstruct_1.is)(value, exports.JSXElementStruct);
}
exports.isJSXElement = isJSXElement;
/**
 * Check if a value is a JSX element, without validating all of its contents.
 * This is useful when you want to validate the structure of a value, but not
 * all the children.
 *
 * This should only be used when you are sure that the value is safe to use,
 * i.e., after using {@link isJSXElement}.
 *
 * @param value - The value to check.
 * @returns True if the value is a JSX element, false otherwise.
 */
function isJSXElementUnsafe(value) {
    return ((0, utils_1.isPlainObject)(value) &&
        (0, utils_1.hasProperty)(value, 'type') &&
        (0, utils_1.hasProperty)(value, 'props') &&
        (0, utils_1.hasProperty)(value, 'key'));
}
exports.isJSXElementUnsafe = isJSXElementUnsafe;
/**
 * Assert that a value is a JSX element.
 *
 * @param value - The value to check.
 * @throws If the value is not a JSX element.
 */
function assertJSXElement(value) {
    // TODO: We should use the error parsing utils from `snaps-utils` to improve
    // the error messages. It currently includes colours and potentially other
    // formatting that we might not want to include in the SDK.
    if (!isJSXElement(value)) {
        throw new Error(`Expected a JSX element, but received ${JSON.stringify(value)}. Please refer to the documentation for the supported JSX elements and their props.`);
    }
}
exports.assertJSXElement = assertJSXElement;
//# sourceMappingURL=validation.cjs.map