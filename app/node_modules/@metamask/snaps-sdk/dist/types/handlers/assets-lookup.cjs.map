{"version":3,"file":"assets-lookup.cjs","sourceRoot":"","sources":["../../../src/types/handlers/assets-lookup.ts"],"names":[],"mappings":";;;AACA,uDAW+B;AAC/B,2CAIyB;AAEZ,QAAA,uBAAuB,GAAG,IAAA,oBAAM,EAAC;IAC5C,IAAI,EAAE,IAAA,sBAAQ,EAAC,IAAA,oBAAM,GAAE,CAAC;IACxB,MAAM,EAAE,IAAA,sBAAQ,EAAC,IAAA,oBAAM,GAAE,CAAC;IAC1B,QAAQ,EAAE,IAAA,oBAAM,GAAE;CACnB,CAAC,CAAC;AAIU,QAAA,kBAAkB,GAAG,IAAA,oBAAM,EAAC,IAAA,oBAAM,GAAE,EAAE,WAAW,EAAE,CAAC,KAAK,EAAE,EAAE;IACxE,IAAI,CAAC;QACH,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC;QAC3B,+EAA+E;QAC/E,IAAA,cAAM,EACJ,GAAG,CAAC,QAAQ,KAAK,QAAQ;YACvB,KAAK,CAAC,UAAU,CAAC,4BAA4B,CAAC,CACjD,CAAC;QACF,OAAO,IAAI,CAAC;IACd,CAAC;IAAC,MAAM,CAAC;QACP,OAAO,aAAa,CAAC;IACvB,CAAC;AACH,CAAC,CAAC,CAAC;AAEU,QAAA,2BAA2B,GAAG,IAAA,oBAAM,EAAC;IAChD,IAAI,EAAE,IAAA,sBAAQ,EAAC,IAAA,oBAAM,GAAE,CAAC;IACxB,MAAM,EAAE,IAAA,sBAAQ,EAAC,IAAA,oBAAM,GAAE,CAAC;IAC1B,QAAQ,EAAE,IAAA,qBAAO,EAAC,IAAI,CAAC;IACvB,OAAO,EAAE,0BAAkB;IAC3B,KAAK,EAAE,IAAA,kBAAI,EAAC,IAAA,mBAAK,EAAC,+BAAuB,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC;CACzD,CAAC,CAAC;AAEU,QAAA,4BAA4B,GAAG,IAAA,oBAAM,EAAC;IACjD,MAAM,EAAE,IAAA,oBAAM,EAAC,2BAAmB,EAAE,IAAA,sBAAQ,EAAC,mCAA2B,CAAC,CAAC;CAC3E,CAAC,CAAC","sourcesContent":["import type { Infer } from '@metamask/superstruct';\nimport {\n  array,\n  size,\n  literal,\n  number,\n  object,\n  refine,\n  string,\n  record,\n  nullable,\n  optional,\n} from '@metamask/superstruct';\nimport {\n  assert,\n  CaipAssetTypeStruct,\n  type CaipAssetType,\n} from '@metamask/utils';\n\nexport const FungibleAssetUnitStruct = object({\n  name: optional(string()),\n  symbol: optional(string()),\n  decimals: number(),\n});\n\nexport type FungibleAssetUnit = Infer<typeof FungibleAssetUnitStruct>;\n\nexport const AssetIconUrlStruct = refine(string(), 'Asset URL', (value) => {\n  try {\n    const url = new URL(value);\n    // For now, we require asset URLs to either be base64 SVGs or remote HTTPS URLs\n    assert(\n      url.protocol === 'https:' ||\n        value.startsWith('data:image/svg+xml;base64,'),\n    );\n    return true;\n  } catch {\n    return 'Invalid URL';\n  }\n});\n\nexport const FungibleAssetMetadataStruct = object({\n  name: optional(string()),\n  symbol: optional(string()),\n  fungible: literal(true),\n  iconUrl: AssetIconUrlStruct,\n  units: size(array(FungibleAssetUnitStruct), 1, Infinity),\n});\n\nexport const OnAssetsLookupResponseStruct = object({\n  assets: record(CaipAssetTypeStruct, nullable(FungibleAssetMetadataStruct)),\n});\n\nexport type FungibleAssetMetadata = Infer<typeof FungibleAssetMetadataStruct>;\n\nexport type OnAssetsLookupArguments = {\n  assets: CaipAssetType[];\n};\n\n/**\n * The `onAssetsLookup` handler. This is called by MetaMask when querying about specific assets on specific chains.\n *\n * @returns The metadata about each asset. See\n * {@link OnAssetsLookupResponse}.\n */\nexport type OnAssetsLookupHandler = (\n  args: OnAssetsLookupArguments,\n) => Promise<OnAssetsLookupResponse>;\n\n/**\n * The response from the query, containing metadata about each requested asset.\n *\n * @property assets - An object containing a mapping between the CAIP-19 key and a metadata object or null.\n */\nexport type OnAssetsLookupResponse = {\n  assets: Record<CaipAssetType, FungibleAssetMetadata | null>;\n};\n"]}